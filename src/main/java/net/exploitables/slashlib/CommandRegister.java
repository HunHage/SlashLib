package net.exploitables.slashlib;

import discord4j.discordjson.json.ApplicationCommandData;
import discord4j.discordjson.json.ApplicationCommandRequest;
import discord4j.discordjson.possible.Possible;
import discord4j.rest.service.ApplicationService;
import net.exploitables.slashlib.commands.ChatCommand;
import net.exploitables.slashlib.commands.GroupCommand;
import net.exploitables.slashlib.commands.TopCommand;
import net.exploitables.slashlib.commands.UserCommand;
import reactor.util.Logger;
import reactor.util.Loggers;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class CommandRegister {
    private static final Logger logger = Loggers.getLogger(CommandRegister.class);

    private final CommandStructure commandStructure;

    protected CommandRegister() {
        this.commandStructure = new CommandStructure();
    }

    /**
     * Create a new CommandRegister with a list of commands.
     * @param chatCommands a list of commands which must be an instance of {@link TopCommand} or {@link GroupCommand}
     * @param userCommands a list of user context menu commands
     * @return a new CommandRegister instance
     */
    static CommandRegister create(List<ChatCommand> chatCommands, List<UserCommand> userCommands) {
        logger.debug("Creating CommandRegister");
        CommandRegister commandRegister = new CommandRegister();
        for (ChatCommand command : chatCommands) {
            logger.debug("Adding Chat Command: " + command.getName());
            commandRegister.commandStructure.addChatCommand(command);
        }
        for (UserCommand command : userCommands) {
            logger.debug("Adding User Command: " + command.getName());
            commandRegister.commandStructure.addUserCommand(command);
        }
        logger.debug("CommandRegister created");
        return commandRegister;
    }

    /**
     * Synchronize all application commands (chat/user/message) with Discord.
     *
     * We merge all requests into a single list as Discord treats them all the same.
     *
     * @param applicationService the bots {@link ApplicationService}
     * @param applicationId the bots Application ID, must match the service
     * @return the number of application commands created/modified/deleted
     */
    public int registerCommands(ApplicationService applicationService, long applicationId) {
        logger.debug("Registering slash commands with Discord");
        int changes = 0;

        Map<String, ApplicationCommandData> discordCmds = applicationService
            .getGlobalApplicationCommands(applicationId)
            .collectMap(ApplicationCommandData::name)
            .block();
        Objects.requireNonNull(discordCmds, "Couldn't get Global Application Commands from Discord");

        Map<String, ApplicationCommandRequest> commandRequests = new HashMap<>();
        for (ChatCommand chatCommand : commandStructure.getChatCommands().values()) {
            commandRequests.put(chatCommand.getName(), chatCommand.asRequest());
        }
        for (UserCommand userCommand : commandStructure.getUserCommands().values()) {
            commandRequests.put(userCommand.getName(), userCommand.asRequest());
        }

        // Create/Update Chat commands
        for (ApplicationCommandRequest request : commandRequests.values()) {
            // Command doesn't exist discord side, create it
            if (discordCmds.get(request.name()) == null) {
                logger.info("Creating Command: " + request.name());
                applicationService.createGlobalApplicationCommand(applicationId, request).block();
                changes++;
                continue;
            }
            // Command exists discord side, check if it's equal to the bot command
            ApplicationCommandData discordCmd = discordCmds.get(request.name());
            if (!commandDataEqualsRequest(discordCmd, request)) {
                logger.info("Updating Command: " + discordCmd.name());
                applicationService.modifyGlobalApplicationCommand(applicationId, Long.parseLong(discordCmd.id()), request).block();
                changes++;
            }
        }

        // Delete removed commands
        for (ApplicationCommandData discordCmd : discordCmds.values()) {
            if (commandRequests.get(discordCmd.name()) == null) {
                logger.info("Deleting Command: " + discordCmd.name());
                applicationService.deleteGlobalApplicationCommand(applicationId, Long.parseLong(discordCmd.id())).block();
                changes++;
            }
        }

        logger.info("Created/Updated/Deleted " + changes + " slash commands");
        return changes;
    }

    /**
     * Check if a slash commands data returned by Discord matches the local slash command request.
     * The names of each parameter should be the same.
     *
     * @param acd the {@link ApplicationCommandData} returned by Discord for a slash command
     * @param acr the {@link ApplicationCommandRequest} created for the same slash command locally
     * @return true if the local slash command is equal to the one registered on Discord
     */
    private boolean commandDataEqualsRequest(ApplicationCommandData acd, ApplicationCommandRequest acr) {
        if (!(acr.name().equals(acd.name())
            && acr.description().toOptional().map(desc -> desc.equals(acd.description())).orElse(false)
            && defaultPermissionEquals(acr.defaultPermission(), acd.defaultPermission()) )) {
            return false;
        }

        if (!acd.options().isAbsent() && !acr.options().isAbsent()) { // Both have options
            return acd.options().get().equals(acr.options().get());
        } else { // If both don't have options return true, otherwise false
            return acd.options().isAbsent() && acr.options().isAbsent();
        }
    }

    /**
     * The default permission must be set in the {@link ApplicationCommandRequest} but doesn't have to be present
     * in a {@link ApplicationCommandData}. This checks for equivalency between the two.
     *
     * @param p1 a Possible representing the default permission value
     * @param p2 a Possible representing the default permission value
     * @return true if the two possibles are equivalent in the context of being set for the default permission
     */
    private boolean defaultPermissionEquals(Possible<Boolean> p1, Possible<Boolean> p2) {
        // The data may not have the permission value present due to behavior as of D4J v3.2.0-RC2
        // By default, D4J will set the requests' default permission to true

        // Each half will return true if the value itself is true or if it is not present (two states for true)
        //  it will return false only when the value itself is false
        // In total this statement will return true only if the values equate to the default permission being true,
        //  or both values are false
        return p1.toOptional().orElse(true) == p2.toOptional().orElse(true);
    }

    public CommandStructure getCommandStructure() { return commandStructure; }
}
