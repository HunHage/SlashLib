package net.exploitables.slashlib.utility;

import discord4j.core.object.command.ApplicationCommandInteraction;
import discord4j.core.object.command.ApplicationCommandInteractionOption;
import discord4j.core.object.command.ApplicationCommandInteractionOptionValue;
import discord4j.core.object.command.ApplicationCommandOption;
import discord4j.core.object.entity.Role;
import discord4j.core.object.entity.User;
import discord4j.core.object.entity.channel.Channel;
import discord4j.discordjson.json.ApplicationCommandOptionData;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * A wrapper class for a list of {@link ApplicationCommandInteractionOption}.
 *
 * Since Top level commands have their options contained within an {@link ApplicationCommandInteraction}
 *  but subcommands have their options contained within an {@link ApplicationCommandInteractionOption}.
 *
 * Since access to these needs to be uniform this wrapper class adds functionality to the options list.
 */
public class OptionsList {
    private final List<ApplicationCommandInteractionOption> options;

    public OptionsList(List<ApplicationCommandInteractionOption> options) {
        this.options = options;
    }

    /**
     * @return the list of options this instance wraps around
     */
    public List<ApplicationCommandInteractionOption> getOptions() {
        return this.options;
    }

    /**
     * Get the entry corresponding to the provided option name if it exists.
     *
     * @param name the name of the option to get
     * @return a present optional if an option exists with the provided name
     */
    public Optional<ApplicationCommandInteractionOption> getOption(String name) {
        return this.options.stream().filter(option -> option.getName().equals(name)).findFirst();
    }

    /**
     * Get the value of the option with the specified name, for a String option type.
     *
     * @param name the name of the option to get
     * @return a present {@link String} if an option exists with the provided name *and* has a value
     */
    public Optional<String> getString(String name) {
        return getOption(name)
            .flatMap(ApplicationCommandInteractionOption::getValue)
            .map(ApplicationCommandInteractionOptionValue::asString);
    }

    /**
     * Get the value of the option with the specified name, for an integer option type.
     *
     * @param name the name of the option to get
     * @return a present {@link Long} if an option exists with the provided name *and* has a value
     */
    public Optional<Long> getInteger(String name) {
        return getOption(name)
            .flatMap(ApplicationCommandInteractionOption::getValue)
            .map(ApplicationCommandInteractionOptionValue::asLong);
    }

    /**
     * Get the value of the option with the specified name, for a Boolean option type.
     *
     * @param name the name of the option to get
     * @return a present {@link Boolean} if an option exists with the provided name *and* has a value
     */
    public Optional<Boolean> getBoolean(String name) {
        return getOption(name)
            .flatMap(ApplicationCommandInteractionOption::getValue)
            .map(ApplicationCommandInteractionOptionValue::asBoolean);
    }

    /**
     * Get the value of the option with the specified name, for a User option type.
     *
     * @param name the name of the option to get
     * @return a non empty {@link Mono<User>} if an option exists with the provided name *and* has a value
     */
    public Mono<User> getUser(String name) {
        return Mono.justOrEmpty(getOption(name)
                .flatMap(ApplicationCommandInteractionOption::getValue))
            .flatMap(ApplicationCommandInteractionOptionValue::asUser);
    }

    /**
     * Get the value of the option with the specified name, for a channel option type.
     *
     * @param name the name of the option to get
     * @return a non empty {@link Mono<Channel>} if an option exists with the provided name *and* has a value
     */
    public Mono<Channel> getChannel(String name) {
        return Mono.justOrEmpty(getOption(name)
                .flatMap(ApplicationCommandInteractionOption::getValue))
            .flatMap(ApplicationCommandInteractionOptionValue::asChannel);
    }

    /**
     * Get the value of the option with the specified name, for a Role option type.
     *
     * @param name the name of the option to get
     * @return a non empty {@link Mono<Role>} if an option exists with the provided name *and* has a value
     */
    public Mono<Role> getRole(String name) {
        return Mono.justOrEmpty(getOption(name)
            .flatMap(ApplicationCommandInteractionOption::getValue))
        .flatMap(ApplicationCommandInteractionOptionValue::asRole);
    }


    /**
     * Get the value of the option with the specified name, for a Number option type.
     *
     * @param name the name of the option to get
     * @return a non empty {@link Optional<Double>} if an option exists with the provided name *and* has a value
     */
    public Optional<Double> getNumber(String name) {
        return getOption(name)
                .flatMap(ApplicationCommandInteractionOption::getValue)
                .map(ApplicationCommandInteractionOptionValue::asDouble);
    }

    /**
     * Checks if all {@link ApplicationCommandInteractionOption}
     * instances in a list are valid options within a list of {@link ApplicationCommandOptionData}.
     * @param normalOptions List of ApplicationCommandOptionData instances.
     * @param aciOptions List of ApplicationCommandInteractionOption instances.
     * @return true if all ACIOption instances are present in the ACOData list
     * (same name, same types and same sub-options (if subcommand)) and if all required ACOData are in the ACIOption list.
     * false otherwise.
     */
    public static boolean compareOptionDataAndAciOptions(List<ApplicationCommandOptionData> normalOptions,
                                                         List<ApplicationCommandInteractionOption> aciOptions) {
        if (aciOptions == null) aciOptions = new ArrayList<>();
        if (normalOptions == null || normalOptions.isEmpty()) {
            return aciOptions.isEmpty();  // return false if specified options when there aren't any
        }
        boolean aciEmpty = aciOptions.isEmpty();
        boolean optionsAreValid = true;
        ApplicationCommandInteractionOption firstAciOption = aciEmpty ? null : aciOptions.get(0);  // for the gateway client
        List<String> aciNames = new ArrayList<>();
        List<String> currentlyUnknownNames = new ArrayList<>();
        for (ApplicationCommandOptionData optData : normalOptions) {
            if (aciEmpty) {
                if (!optData.required().isAbsent() && optData.required().get()) {
                    optionsAreValid = false;  // there's a required option, while the aciOptions list is empty.
                    break;
                }
            } else {
                ApplicationCommandOption opt = new ApplicationCommandOption(firstAciOption.getClient(), optData);
                boolean thisOptionIsThere = !opt.isRequired();  // if optional option then not being there is OK
                for (ApplicationCommandInteractionOption aciOption : aciOptions) {
                    String aciName = aciOption.getName();
                    if (aciName.equals(opt.getName())) {  // same option name
                        thisOptionIsThere = aciOption.getType().equals(opt.getType())
                                && compareOptionsAndAciOptions(opt.getOptions(), aciOption.getOptions());
                        // set to false if the option name is there but the type is different.

                        if (aciNames.contains(aciName)) {
                            currentlyUnknownNames.remove(aciName);
                        } else {
                            aciNames.add(aciName);
                        }
                        break;
                    } else if (!aciNames.contains(aciName)) {
                        aciNames.add(aciName);
                        currentlyUnknownNames.add(aciName);
                    }
                }
                if (!thisOptionIsThere) {
                    optionsAreValid = false;
                    break;
                }
            }
        }
        return optionsAreValid && (currentlyUnknownNames.size() == 0);  // required options are there + no unknown options
    }

    /**
     * Checks if all {@link ApplicationCommandInteractionOption}
     * instances in a list are valid options within a list of {@link ApplicationCommandOption}.
     * @param normalOptions List of ApplicationCommandOption instances.
     * @param aciOptions List of ApplicationCommandInteractionOption instances.
     * @return true if all ACIOption instances are present in the ACOption list
     * (same name, same types and same sub-options (if subcommand)) and if all required ACOptions are in the ACIOption list.
     * false otherwise.
     */
    public static boolean compareOptionsAndAciOptions(List<ApplicationCommandOption> normalOptions,
                                                      List<ApplicationCommandInteractionOption> aciOptions) {
        if (aciOptions == null) aciOptions = new ArrayList<>();
        if (normalOptions == null || normalOptions.isEmpty()) {
            return aciOptions.isEmpty();  // return false if specified options when there aren't any
        }
        boolean optionsAreValid = true;
        List<String> aciNames = new ArrayList<>();
        List<String> currentlyUnknownNames = new ArrayList<>();
        for (ApplicationCommandOption opt : normalOptions) {
            boolean thisOptionIsThere = !opt.isRequired();  // if optional option then not being there is OK
            for (ApplicationCommandInteractionOption aciOption : aciOptions) {
                String aciName = aciOption.getName();
                if (aciName.equals(opt.getName())) {  // same option name
                    thisOptionIsThere = aciOption.getType().equals(opt.getType())
                            && compareOptionsAndAciOptions(opt.getOptions(), aciOption.getOptions());
                    // set to false if the option name is there but the type is different.

                    if (aciNames.contains(aciName)) {
                        currentlyUnknownNames.remove(aciName);
                    } else {
                        aciNames.add(aciName);
                    }
                    break;
                } else if (!aciNames.contains(aciName)) {
                    aciNames.add(aciName);
                    currentlyUnknownNames.add(aciName);
                }
            }
            if (!thisOptionIsThere) {
                optionsAreValid = false;
                break;
            }
        }
        return optionsAreValid && (currentlyUnknownNames.size() == 0);  // required options are there + no unknown options
    }
}
