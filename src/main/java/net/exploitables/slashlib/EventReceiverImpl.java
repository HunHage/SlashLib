package net.exploitables.slashlib;


import discord4j.core.event.domain.interaction.ChatInputInteractionEvent;
import discord4j.core.event.domain.interaction.DeferrableInteractionEvent;
import discord4j.core.event.domain.interaction.MessageInteractionEvent;
import discord4j.core.event.domain.interaction.UserInteractionEvent;
import discord4j.core.object.entity.channel.GuildChannel;
import net.exploitables.slashlib.commands.BaseCommand;
import net.exploitables.slashlib.context.*;
import reactor.core.publisher.Mono;

public class EventReceiverImpl<
        IC extends ChatInputContext, IB extends ChatInputContextBuilder,
        MC extends MessageContext, MB extends MessageContextBuilder,
        UC extends UserContext, UB extends UserContextBuilder
        > implements EventReceiver<IC, UC, MC> {

    private final SlashLib<IC, IB, MC, MB, UC, UB> slashLib;

    public EventReceiverImpl(SlashLib<IC, IB, MC, MB, UC, UB> slashLib) {
        this.slashLib = slashLib;
    }

    private <E extends DeferrableInteractionEvent, B extends BaseCommand> Mono<Boolean> checkPermissions(E event, B baseCommand) {
        return event.getInteraction()
            .getChannel()
            .ofType(GuildChannel.class)
            .flatMap(gc -> gc.getEffectivePermissions(event.getClient().getSelfId()))
            .map(perms -> perms.containsAll(baseCommand.getBotPermissions()))
            .switchIfEmpty(Mono.just(false))
            .filter(havePerms -> havePerms || baseCommand.isUsableInDMs())
            // No perms and not usable in DMs, send silent error message
            .switchIfEmpty(Mono.defer(() -> {
                String content;
                if (!baseCommand.getBotPermissions().isEmpty()) {
                    content = "I need the following permissions for that command: " +
                            baseCommand.getBotPermissions().asEnumSet();
                } else {
                    content = "That is not usable in DMs.";
                }
                // .then(Mono.empty()) for type compatibility
                return event.reply(content).withEphemeral(true).then(Mono.empty());
            }));
    }

    @Override
    public Mono<IC> receiveChatInputInteractionEvent(ChatInputInteractionEvent event) {
        // We need the command interaction to get the options
        return Mono.justOrEmpty(event.getInteraction().getCommandInteraction())
            // Get the command, we use the helper method on the command Structure to get this as
            //  chat input commands care multi-level
            .flatMap(aci -> Mono.just(slashLib.getCommandRegister().getCommandStructure().searchForChatCommand(aci))
                // Check bot permissions in guild
                .flatMap(pair -> checkPermissions(event, pair.getKey())
                    // Have perms, create the builder and collect data
                    .flatMap(_bool -> {
                        try {
                            return pair.getKey()
                                .setRequestData(slashLib.chatInputContextBuilderConstructor.newInstance(event, aci, pair.getValue()))
                                .collectData();
                        } catch (Exception e) {
                            return Mono.error(e);
                        }
                    })
                    .ofType(slashLib.chatInputContextBuilderClass)
                    .map(ChatInputContextBuilder::build)
                    .ofType(slashLib.chatInputContextClass)
                    // Call the command
                    .flatMap(context -> pair.getKey().executeChat(context))));
}

    @Override
    public Mono<UC> receiveUserInteractionEvent(UserInteractionEvent event) {
        // Since User Interactions are only top level we can just get our command by the name
        return Mono.just(slashLib.getCommandRegister().getCommandStructure().getUserCommands().get(event.getCommandName()))
            // Check bot permissions in guild
            .flatMap(userCommand -> checkPermissions(event, userCommand)
                // Have perms, create the builder and collect data
                .flatMap(_bool -> {
                    try {
                        return userCommand.setRequestData(slashLib.userContextBuilderConstructor.newInstance(event))
                            .collectData();
                    } catch (Exception e) {
                        return Mono.error(e);
                    }
                })
                .ofType(slashLib.userContextBuilderClass)
                .map(UserContextBuilder::build)
                .ofType(slashLib.userContextClass)
                // Call the command
                .flatMap(userCommand::executeUser));
    }

    @Override
    public Mono<MC> receiveMessageInteractionEvent(MessageInteractionEvent event) {
        // Since User Interactions are only top level we can just get our command by the name
        return Mono.just(slashLib.getCommandRegister().getCommandStructure().getMessageCommands().get(event.getCommandName()))
            // Check bot permissions in guild
            .flatMap(messageCommand -> checkPermissions(event, messageCommand)
                // Have perms, create the builder and collect data
                .flatMap(_bool -> {
                    try {
                        return messageCommand.setRequestData(slashLib.messageContextBuilderConstructor.newInstance(event))
                            .collectData();
                    } catch (Exception e) {
                        return Mono.error(e);
                    }
                })
                .ofType(slashLib.messageContextBuilderClass)
                .map(MessageContextBuilder::build)
                .ofType(slashLib.messageContextClass)
                // Call the command
                .flatMap(messageCommand::executeMessage));
    }
}
