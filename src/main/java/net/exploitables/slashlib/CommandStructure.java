package net.exploitables.slashlib;

import discord4j.core.object.command.ApplicationCommandInteraction;
import discord4j.core.object.command.ApplicationCommandInteractionOption;
import net.exploitables.slashlib.commands.*;
import net.exploitables.slashlib.utility.CommandOptionPair;

import java.util.*;

/**
 * A representation of the command structure used for slash commands.
 *
 * Some notes on my (HunHage) observations about slash commands
 * - Each "path" in the command tree must lead to a command.
 * -- This means if /command sub_command is a command then /command is not a callable command.
 * -- Same goes for /command group_command sub_command for command and group_command.
 * - The "name" of any type of command is just the name of that command.
 * -- /command group_command sub_command each have their own names and don't contain each other.
 * -- Discord seems to only navigate down, not up. See the next note section about options.
 * - The Group and Sub commands are options of the above command.
 * -- Knowing about the "path" and "name" means that if a command is not callable then it will
 *     have one option of type GROUP_COMMAND or SUB_COMMAND. We can assume that if there is 0 options,
 *     1 option that is not group/sub, or 2+ options of any type then the command is callable. This is key.
 *
 * With the above observations a tree is the optimal choice for organizing slash commands by name.
 * That is what this class exists to do.
 *
 * Where Discord slash commands exist as:
 * Root
 * - Command
 * - Command
 * -- SubCommand
 * -- SubCommand
 * -- GroupCommand
 * --- SubCommand
 *
 * The Tree will use classes as:
 * CommandStructure
 * - TopCommand
 * - TopGroupCommand
 * -- SubCommand
 * -- SubCommand
 * -- MidGroupCommand
 * --- SubCommand
 *
 * Commands need no knowledge of their parent or involvement in the tree.
 * Since only Commands and SubCommands are callable, GroupCommands are used for each uncallable command.
 *
 * User and Message context menu "commands" are kept in their own hashmap to avoid name collisions but are assembled
 *  as TopCommands when creating request data.
 */
public class CommandStructure {
    private final Map<String, ChatCommand> chatCommands;
    private final Map<String, UserCommand> userCommands;
    private final Map<String, MessageCommand> messageCommands;
    private final Set<Long> commandGuildIDs;

    /**
     * Create the Command Structure used for Slash Commands
     */
    public CommandStructure() {
        chatCommands = new HashMap<>();
        userCommands = new HashMap<>();
        messageCommands = new HashMap<>();
        commandGuildIDs = new HashSet<>();
    }

    /**
     * Get the Command called with a slash command.
     * Since Discord only allows callable commands to be called, we will have a command to return.
     *
     * @param aci the ApplicationCommandInteraction for a Slash Command
     * @return the Command being called
     */
    public CommandOptionPair searchForChatCommand(ApplicationCommandInteraction aci) {
        Objects.requireNonNull(aci.getName().orElse(null), "ApplicationCommandInteraction name missing!");
        ChatCommand command = this.chatCommands.get(aci.getName().get());
        List<ApplicationCommandInteractionOption> options = aci.getOptions();
        // If there is only one option and it's a SubCommand or SubCommandGroup option then search for it
        if (options.size() == 1 && options.get(0).getType().getValue() < 3) {
            return searchForChatCommand(command, options);
        } else {
            return new CommandOptionPair(command, options);
        }
    }

    /**
     * Search for a second or third level command recursively
     * @param command the command to check and search
     * @param options the options for this command
     * @return a callable command
     */
    private CommandOptionPair searchForChatCommand(ChatCommand command, List<ApplicationCommandInteractionOption> options) {
        // If there is only one option and it's a SubCommand or SubCommandGroup option then search for it
        if (options.size() == 1 && options.get(0).getType().getValue() < 3) {
            ApplicationCommandInteractionOption option = options.get(0);
            return searchForChatCommand(command.getSubCommand(option.getName()), option.getOptions());
        } else {
            return new CommandOptionPair(command, options);
        }
    }

    /**
     * Add a command to this group, can be a TopCommand or TopGroupCommand
     *
     * @param command the sub command to add to this group
     */
    public void addChatCommand(ChatCommand command) {
        if (!(command instanceof TopCommand || command instanceof TopGroupCommand)) {
            throw new InvalidCommandLocationException(command, "TopCommand or TopGroupCommand");
        }
        chatCommands.put(command.getName(), command);

        Long[] thisCmdGuildIDs = command.getGuildIDs();
        if (!command.isGlobal() && thisCmdGuildIDs != null) {
            commandGuildIDs.addAll(Arrays.asList(thisCmdGuildIDs));  // keep track of guild-restricted commands
        }
    }

    /**
     * Add a user command to this structure.
     *
     * @param command the user context command to add
     */
    public void addUserCommand(UserCommand command) {
        userCommands.put(command.getName(), command);

        Long[] thisCmdGuildIDs = command.getGuildIDs();
        if (!command.isGlobal() && thisCmdGuildIDs != null) {
            commandGuildIDs.addAll(Arrays.asList(thisCmdGuildIDs));  // keep track of guild-restricted commands
        }
    }

    /**
     * Add a message command to this structure.
     *
     * @param command the message context command to add
     */
    public void addMessageCommand(MessageCommand command) {
        messageCommands.put(command.getName(), command);

        Long[] thisCmdGuildIDs = command.getGuildIDs();
        if (!command.isGlobal() && thisCmdGuildIDs != null) {
            commandGuildIDs.addAll(Arrays.asList(thisCmdGuildIDs));  // keep track of guild-restricted commands
        }
    }

    public Map<String, ChatCommand> getChatCommands() { return this.chatCommands; }
    public Map<String, UserCommand> getUserCommands() { return this.userCommands; }
    public Map<String, MessageCommand> getMessageCommands() { return this.messageCommands; }
    public Set<Long> getCommandGuildIDs() {
        return commandGuildIDs;
    }

    /**
     * Retrieves all global chat commands specified.
     * @return Map with global chat commands.
     */
    public Map<String, ChatCommand> getGlobalChatCommands() {
        Map<String, ChatCommand> globalChatCommands = new HashMap<>();
        for (Map.Entry<String, ChatCommand> cmdEntry : this.chatCommands.entrySet()) {
            String key = cmdEntry.getKey();
            ChatCommand value = cmdEntry.getValue();
            if (value.isGlobal()) {
                globalChatCommands.put(key, value);
            }
        }
        return globalChatCommands;
    }

    /**
     * Retrieves all global user commands specified.
     * @return Map with global user commands.
     */
    public Map<String, UserCommand> getGlobalUserCommands() {
        Map<String, UserCommand> globalUserCommands = new HashMap<>();
        for (Map.Entry<String, UserCommand> cmdEntry : this.userCommands.entrySet()) {
            String key = cmdEntry.getKey();
            UserCommand value = cmdEntry.getValue();
            if (value.isGlobal()) {
                globalUserCommands.put(key, value);
            }
        }
        return globalUserCommands;
    }

    /**
     * Retrieves all global message commands specified.
     * @return Map with global message commands.
     */
    public Map<String, MessageCommand> getGlobalMessageCommands() {
        Map<String, MessageCommand> globalMessageCommands = new HashMap<>();
        for (Map.Entry<String, MessageCommand> cmdEntry : this.messageCommands.entrySet()) {
            String key = cmdEntry.getKey();
            MessageCommand value = cmdEntry.getValue();
            if (value.isGlobal()) {
                globalMessageCommands.put(key, value);
            }
        }
        return globalMessageCommands;
    }

    /**
     * Retrieves all guild-restricted commands of the specified type, in all guilds, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @return Map with ALL guild-restricted commands of the given type (per guild ID).
     */
    private <C extends BaseCommand> Map<Long, Map<String, C>> getGuildCommandsForType(Map<String, C> commands) {
        Map<Long, Map<String, C>> allGuildCommands = new HashMap<>();
        for (Map.Entry<String, C> cmdEntry : commands.entrySet()) {
            String key = cmdEntry.getKey();
            C value = cmdEntry.getValue();
            Long[] thisCmdGuildIDs = value.getGuildIDs();
            if (!value.isGlobal() && thisCmdGuildIDs != null) {
                for (long guildID : thisCmdGuildIDs) {
                    Map<String, C> guildCommands = allGuildCommands.getOrDefault(guildID, new HashMap<>());
                    guildCommands.put(key, value);
                    allGuildCommands.put(guildID, guildCommands);
                }
            }
        }
        return allGuildCommands;
    }

    /**
     * Retrieves all guild-restricted commands of the given type in the specified guild IDs, in the form of a map of maps
     * (key: guild ID; value: map with chat commands restricted to this guild ID, in the form of k: command name and
     * v: command instance.)
     * @param guildIDs Guilds to check for commands restricted to them.
     * @return Map with all guild-restricted commands of the given type in the given guilds (per guild ID).
     */
    private <C extends BaseCommand> Map<Long, Map<String, C>> getGuildCommandsForType(Map<String, C> commands, Long[] guildIDs) {
        Map<Long, Map<String, C>> allGuildCommands = new HashMap<>();
        List<Long> guildIDsList = new ArrayList<>();
        for (Long givenGuildID : guildIDs) {
            allGuildCommands.put(givenGuildID, new HashMap<>());  // make sure every guildID given has a corresponding
            guildIDsList.add(givenGuildID);                       // command map, even if empty (to avoid null)
        }
        for (Map.Entry<String, C> cmdEntry : commands.entrySet()) {
            String key = cmdEntry.getKey();
            C value = cmdEntry.getValue();
            Long[] thisCmdGuildIDs = value.getGuildIDs();
            if (!value.isGlobal() && thisCmdGuildIDs != null) {
                for (long guildID : thisCmdGuildIDs) {
                    if (guildIDsList.contains(guildID)) {
                        Map<String, C> guildCommands = allGuildCommands.getOrDefault(guildID, new HashMap<>());
                        guildCommands.put(key, value);
                        allGuildCommands.put(guildID, guildCommands);
                    }
                }
            }
        }
        return allGuildCommands;
    }

    /**
     * Retrieves all guild-restricted commands of the specified type, in a certain guild.
     * @param guildID Guild to check.
     * @return Map with guild-restricted commands of the given type in the given guild.
     */
    private <C extends BaseCommand> Map<String, C> getGuildCommandsForType(Map<String, C> commands, long guildID) {
        Map<String, C> guildCommands = new HashMap<>();
        for (Map.Entry<String, C> cmdEntry : commands.entrySet()) {
            String key = cmdEntry.getKey();
            C value = cmdEntry.getValue();
            Long[] thisCmdGuildIDs = value.getGuildIDs();
            if (!value.isGlobal() && thisCmdGuildIDs != null && Arrays.asList(thisCmdGuildIDs).contains(guildID)) {
                guildCommands.put(key, value);
            }
        }
        return guildCommands;
    }

    /**
     * Retrieves all guild-restricted chat commands specified, in all guilds, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @return Map with ALL guild-restricted chat commands (per guild ID).
     */
    public Map<Long, Map<String, ChatCommand>> getGuildChatCommands() {
        return getGuildCommandsForType(this.chatCommands);
    }

    /**
     * Retrieves all guild-restricted chat commands in the specified guild IDs, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @param guildIDs Guilds to check for commands restricted to them.
     * @return Map with all guild-restricted chat commands in the given guilds (per guild ID).
     */
    public Map<Long, Map<String, ChatCommand>> getGuildChatCommands(Long[] guildIDs) {
        return getGuildCommandsForType(this.chatCommands, guildIDs);
    }

    /**
     * Retrieves all guild-restricted chat commands specified, in a certain guild.
     * @param guildID Guild to check.
     * @return Map with chat commands restricted to that guild ID.
     */
    public Map<String, ChatCommand> getGuildChatCommands(long guildID) {
        return getGuildCommandsForType(this.chatCommands, guildID);
    }

    /**
     * Retrieves all guild-restricted user commands specified, in all guilds, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @return Map with ALL guild-restricted chat commands (per guild ID).
     */
    public Map<Long, Map<String, UserCommand>> getGuildUserCommands() {
        return getGuildCommandsForType(this.userCommands);
    }

    /**
     * Retrieves all guild-restricted user commands in the specified guild IDs, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @param guildIDs Guilds to check for commands restricted to them.
     * @return Map with all guild-restricted chat commands in the given guilds (per guild ID).
     */
    public Map<Long, Map<String, UserCommand>> getGuildUserCommands(Long[] guildIDs) {
        return getGuildCommandsForType(this.userCommands, guildIDs);
    }

    /**
     * Retrieves all guild-restricted user commands, in a certain guild.
     * @param guildID Guild to check.
     * @return Map with user commands restricted to that guild.
     */
    public Map<String, UserCommand> getGuildUserCommands(long guildID) {
        return getGuildCommandsForType(this.userCommands, guildID);
    }

    /**
     * Retrieves all guild-restricted message commands specified, in all guilds, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @return Map with ALL guild-restricted message commands (per guild ID).
     */
    public Map<Long, Map<String, MessageCommand>> getGuildMessageCommands() {
        return getGuildCommandsForType(this.messageCommands);
    }

    /**
     * Retrieves all guild-restricted message commands in the specified guild IDs, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @param guildIDs Guilds to check for commands restricted to them.
     * @return Map with all guild-restricted message commands in the given guilds (per guild ID).
     */
    public Map<Long, Map<String, MessageCommand>> getGuildMessageCommands(Long[] guildIDs) {
        return getGuildCommandsForType(this.messageCommands, guildIDs);
    }

    /**
     * Retrieves all guild-restricted message commands, in a certain guild.
     * @param guildID Guild to check.
     * @return Map with message commands restricted to that guild.
     */
    public Map<String, MessageCommand> getGuildMessageCommands(long guildID) {
        return getGuildCommandsForType(this.messageCommands, guildID);
    }
}
