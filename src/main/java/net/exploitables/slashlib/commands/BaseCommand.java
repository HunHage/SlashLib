package net.exploitables.slashlib.commands;

import discord4j.discordjson.json.ApplicationCommandOptionData;
import discord4j.discordjson.json.ApplicationCommandRequest;
import discord4j.discordjson.json.ImmutableApplicationCommandOptionData;
import discord4j.discordjson.json.ImmutableApplicationCommandRequest;
import discord4j.rest.util.ApplicationCommandOptionType;
import discord4j.rest.util.Permission;
import discord4j.rest.util.PermissionSet;
import net.exploitables.slashlib.context.SlashCommandContext;
import net.exploitables.slashlib.context.SlashCommandContextBuilder;
import reactor.core.publisher.Mono;
import reactor.util.annotation.Nullable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

/**
 * A class which represents all types of Slash Commands.
 */
public abstract class BaseCommand {
    // Command Name
    private final String name;
    // Command Description
    private final String description;
    // null when TopCommand: The type of command this is
    private final ApplicationCommandOptionType type;
    // null when no options: Options for the command
    private List<ApplicationCommandOptionData> options;
    // If anyone can use this command by default
    private boolean defaultPermission;
    // Permissions needed by the bot
    private PermissionSet botPermissions;

    // null when not GroupCommand: SubCommands and Sub-GroupCommands
    protected final Map<String, BaseCommand> subCommands;

    protected BaseCommand(String name,
                          String description,
                          @Nullable ApplicationCommandOptionType type) {
        this.name = name;
        this.description = description;
        this.type = type;
        this.options = null;
        this.defaultPermission = true;
        this.botPermissions = PermissionSet.none();

        if (type == ApplicationCommandOptionType.SUB_COMMAND_GROUP) {
            this.subCommands = new HashMap<>();
        } else {
            this.subCommands = null;
        }
    }

    public abstract Mono<SlashCommandContext> execute(SlashCommandContext context);

    public abstract SlashCommandContextBuilder setRequestData(SlashCommandContextBuilder context);

    /**
     * @return a representative {@link ApplicationCommandOptionData} of this class to be used as option data
     */
    public ApplicationCommandOptionData asOptionData() {
        ImmutableApplicationCommandOptionData.Builder builder = ApplicationCommandOptionData.builder()
            .name(this.getName())
            .description(this.getDescription())
            .type(this.getType().getValue());
        List<ApplicationCommandOptionData> options = this.getOptions();
        if (options != null) {
            builder.options(options);
        }
        return builder.build();
    }

    /**
     * @return a representative {@link ApplicationCommandRequest} to compare/create this data with Discord
     */
    public ApplicationCommandRequest asRequest() {
        ImmutableApplicationCommandRequest.Builder builder = ApplicationCommandRequest.builder()
            .name(this.name)
            .description(this.description);
        List<ApplicationCommandOptionData> options = this.getOptions();
        if (options != null) {
            builder.addAllOptions(options);
        }
        if (!this.isDefaultPermission()) { // Avoid the need to check false against an absent possible
            builder.defaultPermission(false);
        }
        return builder.build();
    }

    /**
     * @param option an {@link ApplicationCommandOptionData} to add to this command
     */
    public void addOption(ApplicationCommandOptionData option) {
        if (this.options == null) this.options = new ArrayList<>();
        this.options.add(option);
    }

    /**
     * @param option an {@link ApplicationCommandOptionData} builder consumer to add to this command
     */
    public void addOption(Consumer<ImmutableApplicationCommandOptionData.Builder> option) {
        ImmutableApplicationCommandOptionData.Builder builder = ApplicationCommandOptionData.builder();
        option.accept(builder);
        this.addOption(builder.build());
    }

    /**
     * Get a sub command of this command, only searches one level
     *
     * @param name the name of the sub command to get
     * @return the sub command if present, null if missing
     */
    public BaseCommand getSubCommand(String name) {
        return subCommands.getOrDefault(name, null);
    }

    /**
     * Set that this command requires a permission to be set for users to call it.
     */
    protected void setDefaultPermissionFalse() {
        this.defaultPermission = false;
    }

    /**
     * Set the permissions the bot needs to execute this command.
     *
     * @param permissions a unique list of Discord permissions
     */
    protected void setBotPermissions(Permission... permissions) {
        this.botPermissions = PermissionSet.of(permissions);
    }

    public String getName() { return name; }
    public String getDescription() { return description; }
    public ApplicationCommandOptionType getType() { return type; }
    public List<ApplicationCommandOptionData> getOptions() { return options; }
    public boolean isDefaultPermission() { return defaultPermission; }
    public PermissionSet getBotPermissions() { return botPermissions; }
    public Map<String, BaseCommand> getSubCommands() { return subCommands; }
}
