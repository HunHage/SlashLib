package net.exploitables.slashlib;

import discord4j.core.GatewayDiscordClient;
import discord4j.core.event.EventDispatcher;
import discord4j.core.event.domain.Event;
import discord4j.core.event.domain.interaction.ChatInputInteractionEvent;
import discord4j.core.event.domain.interaction.MessageInteractionEvent;
import discord4j.core.event.domain.interaction.UserInteractionEvent;
import net.exploitables.slashlib.context.*;
import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.Logger;
import reactor.util.Loggers;

import java.lang.reflect.Constructor;
import java.util.function.Function;

public class GenericSlashLib<
        IC extends ChatInputContext, IB extends ChatInputContextBuilder,
        MC extends MessageContext, MB extends MessageContextBuilder,
        UC extends UserContext, UB extends UserContextBuilder
        > {
    private static final Logger logger = Loggers.getLogger(GenericSlashLib.class);

    private static boolean created = false;

    private CommandRegister<IC, IB, MC, MB, UC, UB> commandRegister;
    private GenericEventReceiver<IC, UC, MC> receiver;

    // Chat Input
    final Class<IC> chatInputContextClass;
    final Constructor<IC> chatInputContextConstructor;
    final Class<IB> chatInputContextBuilderClass;
    final Constructor<IB> chatInputContextBuilderConstructor;
    // Message
    final Class<MC> messageContextClass;
    final Constructor<MC> messageContextConstructor;
    final Class<MB> messageContextBuilderClass;
    final Constructor<MB> messageContextBuilderConstructor;
    // User
    final Class<UC> userContextClass;
    final Constructor<UC> userContextConstructor;
    final Class<UB> userContextBuilderClass;
    final Constructor<UB> userContextBuilderConstructor;

    private GenericSlashLib(GenericSlashLibBuilder<IC, IB, MC, MB, UC, UB> builder) {
        this.commandRegister = null;
        this.receiver = null;

        this.chatInputContextClass = builder.chatInputContextClass;
        this.chatInputContextConstructor = builder.chatInputContextConstructor;
        this.chatInputContextBuilderClass = builder.chatInputContextBuilderClass;
        this.chatInputContextBuilderConstructor = builder.chatInputContextBuilderConstructor;

        this.messageContextClass = builder.messageContextClass;
        this.messageContextConstructor = builder.messageContextConstructor;
        this.messageContextBuilderClass = builder.messageContextBuilderClass;
        this.messageContextBuilderConstructor = builder.messageContextBuilderConstructor;

        this.userContextClass = builder.userContextClass;
        this.userContextConstructor = builder.userContextConstructor;
        this.userContextBuilderClass = builder.userContextBuilderClass;
        this.userContextBuilderConstructor = builder.userContextBuilderConstructor;
    }

    /**
     * Create an instance of GenericSlashLib from a builder using defaults if not present. This will do some
     * verification on the commands provided and assert they are the proper classes.
     * @param builder the {@link ChatInputContextBuilder} with custom values
     * @return a new instance of GenericSlashLib which can be used to process commands
     */
    static <
            IC extends ChatInputContext, IB extends ChatInputContextBuilder,
            MC extends MessageContext, MB extends MessageContextBuilder,
            UC extends UserContext, UB extends UserContextBuilder
            > GenericSlashLib<IC, IB, MC, MB, UC, UB> create(GenericSlashLibBuilder<IC, IB, MC, MB, UC, UB> builder) {
        if (created) {
            throw new IllegalStateException("GenericSlashLib already created!");
        }
        GenericSlashLib<IC, IB, MC, MB, UC, UB> genericSlashLib = new GenericSlashLib<>(builder);
        genericSlashLib.receiver = builder.eventReceiverProducer.apply(genericSlashLib);
        genericSlashLib.commandRegister = CommandRegister.create(builder.chatCommands, builder.userCommands, builder.messageCommands);
        created = true;
        return genericSlashLib;
    }

    /**
     * Register a listener for a Discord event with customized logging.
     *
     * @param eventDispatcher the event dispatcher to register with
     * @param event the event to listen for
     * @param mapper the method to call
     * @param <E> any Discord event
     * @param <T> any Publisher which accepts the event
     */
    private <E extends Event, T> void registerListener(EventDispatcher eventDispatcher, Class<E> event, Function<E, Publisher<T>> mapper) {
        eventDispatcher.on(event)
            .flatMap(e -> Flux.defer(() -> mapper.apply(e))
                .onErrorResume(t -> {
                    logger.error("Error while handling CHAT_INPUT event");
                    logger.error(t.getClass().getCanonicalName() + ": " + t.getMessage());
                    return Mono.empty();
                }))
            .subscribe();
    }

    /**
     * Register this instance with an {@link EventDispatcher} to handle:
     * {@link ChatInputInteractionEvent}s when any exist
     * {@link UserInteractionEvent}s when any exist
     *
     * @param eventDispatcher the {@link EventDispatcher} to be used with the bots future {@link GatewayDiscordClient}
     */
    public void registerAsListener(EventDispatcher eventDispatcher) {
        if (commandRegister.getCommandStructure().getChatCommands().size() > 0) {
            registerListener(eventDispatcher, ChatInputInteractionEvent.class, receiver::receiveChatInputInteractionEvent);
        }
        if (commandRegister.getCommandStructure().getUserCommands().size() > 0) {
            registerListener(eventDispatcher, UserInteractionEvent.class, receiver::receiveUserInteractionEvent);
        }
        if (commandRegister.getCommandStructure().getMessageCommands().size() > 0) {
            registerListener(eventDispatcher, MessageInteractionEvent.class, receiver::receiveMessageInteractionEvent);
        }
    }

    /**
     * @return the {@link CommandRegister} used by this instance
     */
    public CommandRegister<IC, IB, MC, MB, UC, UB> getCommandRegister() { return commandRegister; }
}
