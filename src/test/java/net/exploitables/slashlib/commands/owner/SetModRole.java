package net.exploitables.slashlib.commands.owner;

import discord4j.discordjson.json.ApplicationCommandPermissionsData;
import discord4j.discordjson.json.ApplicationCommandPermissionsRequest;
import discord4j.rest.service.ApplicationService;
import net.exploitables.slashlib.CommandStructure;
import net.exploitables.slashlib.context.SlashCommandContext;
import net.exploitables.slashlib.context.SlashCommandContextBuilder;
import net.exploitables.slashlib.examples.ExamplePermissionUsage;
import net.exploitables.slashlib.utility.OptionBuilder;
import reactor.core.publisher.Mono;
import reactor.util.Logger;
import reactor.util.Loggers;

/**
 * A command that should be set to only be used by the owner of a server externally
 */
public class SetModRole extends OwnerTopCommand {
    private static final Logger logger = Loggers.getLogger(SetModRole.class);

    public SetModRole() {
        super("setmodrole", "set the role that can use moderation commands");
        setDefaultPermissionFalse();
        addOption(OptionBuilder.requiredRole("role", "the role that will let members use moderation commands"));
    }

    @Override
    public Mono<SlashCommandContext> execute(SlashCommandContext context) {
        // This command will only work with ExamplePermissionUsage as a reference to the DiscordClient for the bot
        //  is needed to get the CommandStructure
        // Since this is a common access pattern between bots there's no reason to include the client in the context.

        long applicationId = ExamplePermissionUsage.getApplicationId();
        ApplicationService service = context.getEvent().getClient().getRestClient().getApplicationService();
        CommandStructure commands = ExamplePermissionUsage.getSlashLib().getCommandRegister().getCommands();

        return context.getOptions().getRole("role")
            .flatMap(role ->
                // Get the commands
                service.getGlobalApplicationCommands(ExamplePermissionUsage.getApplicationId())
                // Filter out commands that don't need a permission to execute.
                .filter(acd -> !acd.defaultPermission().toOptional().orElse(true))
                // Filter out Owner Commands
                .filter(acd -> !(commands.getSubCommand(acd.name()) instanceof OwnerTopCommand))
                // Modify the commands required role
                .doOnNext(acd -> logger.info("Setting command permission role for: " + acd.name()))
                .flatMap(acd -> service.modifyApplicationCommandPermissions(
                    applicationId,
                    context.getGuild().getId().asLong(),
                    Long.parseLong(acd.id()),
                    // Create the permission request
                    ApplicationCommandPermissionsRequest.builder()
                        // Create the permission data
                        .addPermission(ApplicationCommandPermissionsData.builder()
                            .type(1) // ROLE is 1, USER is 2
                            .id(role.getId().asLong())
                            .permission(true)
                            .build())
                        .build()))
                .then())
            .then(context.getEvent().reply("Permissions set!"))
            .then(Mono.just(context))
            // D4J RC2 and earlier cannot set perms as of 2021-08-14
            .doOnError(Throwable::printStackTrace);
    }

    @Override
    public SlashCommandContextBuilder setRequestData(SlashCommandContextBuilder context) {
        return context.requireGuild();
    }
}
