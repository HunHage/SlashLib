package net.exploitables.slashlib;

import discord4j.discordjson.json.ApplicationCommandData;
import discord4j.discordjson.json.ApplicationCommandOptionData;
import discord4j.discordjson.json.ApplicationCommandRequest;
import discord4j.discordjson.possible.Possible;
import discord4j.rest.service.ApplicationService;
import net.exploitables.slashlib.commands.BaseCommand;

import java.util.List;
import java.util.Map;
import java.util.Objects;

public class CommandRegister {
    //private static final Logger logger = LoggerFactory.getLogger(CommandRegister.class);

    private final CommandStructure commands;

    protected CommandRegister() {
        this.commands = new CommandStructure();
    }

    static CommandRegister create(List<BaseCommand> commandList) {
        CommandRegister commandRegister = new CommandRegister();
        for (BaseCommand command : commandList) {
            commandRegister.addCommand(command);
        }
        return commandRegister;
    }

    private void addCommand(BaseCommand command) {
        this.commands.addSubCommand(command);
    }

    public int registerSlashCommands(ApplicationService applicationService, long applicationId) {
        int changes = 0;

        Map<String, ApplicationCommandData> discordCmds = applicationService
            .getGlobalApplicationCommands(applicationId)
            .collectMap(ApplicationCommandData::name).block();
        // TODO: Need to check what happens when no slash commands are registered
        Objects.requireNonNull(discordCmds, "Couldn't get Global Application Commands from Discord");

        // Create/Update commands
        for (BaseCommand botCmd : commands.getSubCommands().values()) {
            ApplicationCommandRequest request = botCmd.asRequest();
            // Command doesn't exist discord side, create it
            if (discordCmds.get(botCmd.getName()) == null) {
                applicationService.createGlobalApplicationCommand(applicationId, request).block();
                changes++;
                continue;
            }
            // Command exists discord side, check if it's equal to the bot command
            ApplicationCommandData discordCmd = discordCmds.get(botCmd.getName());
            if (!commandDataEqualsRequest(discordCmd, request)) {
                applicationService.modifyGlobalApplicationCommand(applicationId, Long.parseLong(discordCmd.id()), request).block();
                changes++;
            }
        }

        // Delete removed commands
        for (ApplicationCommandData discordCmd : discordCmds.values()) {
            if (commands.getSubCommands().get(discordCmd.name()) == null) {
                applicationService.deleteGlobalApplicationCommand(applicationId, Long.parseLong(discordCmd.id())).block();
                changes++;
            }
        }

        return changes;
    }

    private boolean commandDataEqualsRequest(ApplicationCommandData acd, ApplicationCommandRequest acr) {
        if (!(acr.name().equals(acd.name())
            && acr.description().equals(acd.description())
            && defaultPermissionEquals(acr.defaultPermission(), acd.defaultPermission()) )) {
            return false;
        }

        if (optionsAreEmpty(acd.options(), acr.options())) { // Neither have options
            return true;
        } else if (!acd.options().isAbsent() && !acr.options().isAbsent()){ // Both have options
            return acd.options().get().equals(acr.options().get());
        } else { // One has options, other doesn't
            return false;
        }
    }

    private boolean defaultPermissionEquals(Possible<Boolean> p1, Possible<Boolean> p2) {
        // The data may not have the permission value present due to behavior as of D4J v3.2.0-RC2
        // When setting the default permission to true, the request sends a present possible

        // Each half will return true if the value itself is true or if it is not present (two states for true)
        //  it will return false only when the value itself is false
        // In total this statement will return true only if the values equate to the default permission being true,
        //  or both values are false
        return p1.toOptional().orElse(true) == p2.toOptional().orElse(true);
    }

    private boolean optionsAreEmpty(Possible<List<ApplicationCommandOptionData>> p1, Possible<List<ApplicationCommandOptionData>> p2) {
        // The data may have no value present due to behavior as of D4J v3.2.0-RC2
        // When no options are present, the request sends a present empty list

        // Each half will return true when the list is not present, or has a length of zero
        //  it will return false when the size is not zero
        // In total this statement will return true only if both lists are either absent or have a length of zero
        return p1.toOptional().map(List::size).map(s -> s == 0).orElse(true) && p2.toOptional().map(List::size).map(s -> s == 0).orElse(true);
    }

    public CommandStructure getCommands() { return commands; }
}
