package net.exploitables.slashlib;

import discord4j.discordjson.json.ApplicationCommandData;
import discord4j.discordjson.json.ApplicationCommandOptionChoiceData;
import discord4j.discordjson.json.ApplicationCommandOptionData;
import discord4j.discordjson.json.ApplicationCommandRequest;
import discord4j.discordjson.possible.Possible;
import discord4j.rest.service.ApplicationService;
import net.exploitables.slashlib.commands.BaseCommand;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class CommandRegister {
    //private static final Logger logger = LoggerFactory.getLogger(CommandRegister.class);

    private final CommandStructure commands;

    protected CommandRegister() {
        this.commands = new CommandStructure();
    }

    static CommandRegister create(List<BaseCommand> commandList) {
        CommandRegister commandRegister = new CommandRegister();
        for (BaseCommand command : commandList) {
            commandRegister.addCommand(command);
        }
        return commandRegister;
    }

    private void addCommand(BaseCommand command) {
        this.commands.addSubCommand(command);
    }

    public int registerSlashCommands(ApplicationService applicationService, long applicationId) {
        // Get the commands we have registered
        List<ApplicationCommandData> acds = applicationService.getGlobalApplicationCommands(applicationId).collectList().block();
        Objects.requireNonNull(acds); // TODO: Need to check what happens when no slash commands are registered
        // Get the requests for each command
        List<ApplicationCommandRequest> acrs = new LinkedList<>();
        for (BaseCommand command : commands.getSubCommands().values()) {
            acrs.add(command.asRequest());
        }

        // Check that each Request matches the registered data
        for (int i = 0; i < acrs.size();) {
            ApplicationCommandRequest acr = acrs.get(i);
            ApplicationCommandData acd = acds.stream().filter(a -> a.name().equals(acr.name())).findFirst().orElse(null);
            // Need to create the request, leave it and continue
            if (acd == null) {
                i++;
                continue;
            }
            // Request matches the data, remove the request as it doesn't need to be made
            if (commandDataEqualsRequest(acd, acr)) {
                acrs.remove(i);
                continue;
            }
            // Request doesn't match the data, update it
            applicationService.modifyGlobalApplicationCommand(applicationId, Long.parseLong(acd.id()), acr).block();
            i++;
        }

        // Create each new command
        for (ApplicationCommandRequest acr : acrs) {
            applicationService.createGlobalApplicationCommand(applicationId, acr).block();
        }

        // Delete unreferenced commands
        for (ApplicationCommandData acd : acds) {
            BaseCommand command = commands.getSubCommand(acd.name());
            if (command == null) {
                applicationService.deleteGlobalApplicationCommand(applicationId, Long.parseLong(acd.id()));
            }
        }

        return acrs.size();
    }

    private boolean commandDataEqualsRequest(ApplicationCommandData acd, ApplicationCommandRequest acr) {
        if (!(acr.name().equals(acd.name())
            && acr.description().equals(acd.description())
            && defaultPermissionEquals(acr.defaultPermission(), acd.defaultPermission()) )) {
            return false;
        }

        if (optionsAreEmpty(acd.options(), acr.options())) { // Neither have options
            return true;
        } else if (!acd.options().isAbsent() && !acd.options().isAbsent()){ // Both have options
            return acd.options().get().equals(acr.options().get());
        } else { // One has options, other doesn't
            return false;
        }
    }

    private boolean defaultPermissionEquals(Possible<Boolean> p1, Possible<Boolean> p2) {
        // The data may not have the permission value present due to behavior as of D4J v3.2.0-RC2
        // When setting the default permission to true, the request sends a present possible

        // Each half will return true if the value itself is true or if it is not present (two states for true)
        //  it will return false only when the value itself is false
        // In total this statement will return true only if the values equate to the default permission being true,
        //  or both values are false
        return p1.toOptional().orElse(true) == p2.toOptional().orElse(true);
    }

    private boolean optionsAreEmpty(Possible<List<ApplicationCommandOptionData>> p1, Possible<List<ApplicationCommandOptionData>> p2) {
        // The data may have no value present due to behavior as of D4J v3.2.0-RC2
        // When no options are present, the request sends a present empty list

        // Each half will return true when the list is not present, or has a length of zero
        //  it will return false when the size is not zero
        // In total this statement will return true only if both lists are either absent or have a length of zero
        return p1.toOptional().map(List::size).map(s -> s == 0).orElse(true) && p2.toOptional().map(List::size).map(s -> s == 0).orElse(true);
    }

    public CommandStructure getCommands() { return commands; }
}
