package net.exploitables.slashlib;


import discord4j.core.event.domain.interaction.ChatInputInteractionEvent;
import discord4j.core.event.domain.interaction.DeferrableInteractionEvent;
import discord4j.core.event.domain.interaction.MessageInteractionEvent;
import discord4j.core.event.domain.interaction.UserInteractionEvent;
import discord4j.core.object.entity.channel.GuildChannel;
import net.exploitables.slashlib.commands.BaseCommand;
import net.exploitables.slashlib.context.*;
import reactor.core.publisher.Mono;

/**
 * Core logic and implementation for processing received interactions and executing the relevant command logic.
 *
 * @param <IC> The {@link Class} used for the {@link ChatContext}        provided to commands for execution
 * @param <IB> The {@link Class} used for the {@link ChatContextBuilder} provided to commands for requesting data
 * @param <UC> The {@link Class} used for the {@link UserContext}             provided to commands for execution
 * @param <UB> The {@link Class} used for the {@link UserContextBuilder}      provided to commands for requesting data
 * @param <MC> The {@link Class} used for the {@link MessageContext}          provided to commands for execution
 * @param <MB> The {@link Class} used for the {@link MessageContextBuilder}   provided to commands for requesting data
 */
public class GenericEventReceiverImpl<
        IC extends ChatContext, IB extends ChatContextBuilder,
        UC extends UserContext, UB extends UserContextBuilder,
        MC extends MessageContext, MB extends MessageContextBuilder
        > implements GenericEventReceiver<IC, UC, MC> {

    protected final GenericSlashLib<IC, IB, UC, UB, MC, MB> genericSlashLib;

    /**
     * Create a new instance with a reference to the existing {@link GenericSlashLib} instance.
     * Method is public for custom implementations to access, but should not be directly instantiated.
     *
     * @param genericSlashLib the in-use {@link SlashLib} instance
     */
    public GenericEventReceiverImpl(GenericSlashLib<IC, IB, UC, UB, MC, MB> genericSlashLib) {
        this.genericSlashLib = genericSlashLib;
    }

    /**
     * Check that the bot has permissions to execute the called command. And that the command can be used in a
     *  {@link discord4j.core.object.entity.channel.PrivateChannel} if called from one.
     *
     * If one of the checks fails, the event is responded to and the chain goes empty. As such, no downstream operator
     *  should switch from empty without considering this.
     *
     * @param event the event produced from the called command
     * @param baseCommand the target command to execute
     * @return a present (and true) mono if command execution can continue, empty otherwise
     */
    private <E extends DeferrableInteractionEvent, B extends BaseCommand> Mono<Boolean> checkPermissions(E event, B baseCommand) {
        return event.getInteraction()
            .getChannel()
            .ofType(GuildChannel.class)
            .flatMap(gc -> gc.getEffectivePermissions(event.getClient().getSelfId()))
            .map(perms -> perms.containsAll(baseCommand.getBotPermissions()))
            .switchIfEmpty(Mono.just(false))
            .filter(havePerms -> havePerms || baseCommand.isUsableInDMs())
            // No perms and not usable in DMs, send silent error message
            .switchIfEmpty(Mono.defer(() -> {
                String content;
                if (!baseCommand.getBotPermissions().isEmpty()) {
                    content = "I need the following permissions for that command: " +
                            baseCommand.getBotPermissions().asEnumSet();
                } else {
                    content = "That is not usable in DMs.";
                }
                // .then(Mono.empty()) for type compatibility
                return event.reply(content).withEphemeral(true).then(Mono.empty());
            }));
    }

    /**
     * Receive a CHAT_INPUT interaction, determine the command, check permissions, and execute.
     *
     * @param event the event produced from a user starting an interaction
     * @return empty if command wasn't callable, a present {@link ChatContext} from post command execution otherwise
     */
    @Override
    public Mono<IC> receiveChatInputInteractionEvent(ChatInputInteractionEvent event) {
        // We need the command interaction to get the options
        return Mono.justOrEmpty(event.getInteraction().getCommandInteraction())
            // Get the command, we use the helper method on the command Structure to get this as
            //  chat input commands care multi-level
            .flatMap(aci -> Mono.just(genericSlashLib.getCommandRegister().getCommandStructure().searchForChatCommand(aci))
                // Check bot permissions in guild
                .flatMap(pair -> checkPermissions(event, pair.getKey())
                    // Have perms, create the builder and collect data
                    .flatMap(_bool -> {
                        try {
                            return pair.getKey()
                                .setRequestData(genericSlashLib.getChatInputContextBuilderConstructor().newInstance(event, aci, pair.getValue()))
                                .collectData();
                        } catch (Exception e) {
                            return Mono.error(e);
                        }
                    })
                    .ofType(genericSlashLib.getChatInputContextBuilderClass())
                    .map(ChatContextBuilder::build)
                    .ofType(genericSlashLib.getChatInputContextClass())
                    // Call the command
                    .flatMap(context -> pair.getKey().executeChat(context))));
    }

    /**
     * Receive a USER interaction, determine the command, check permissions, and execute.
     *
     * @param event the event produced from a user starting an interaction
     * @return empty if command wasn't callable, a present {@link UserContext} from post command execution otherwise
     */
    @Override
    public Mono<UC> receiveUserInteractionEvent(UserInteractionEvent event) {
        // Since User Interactions are only top level we can just get our command by the name
        return Mono.just(genericSlashLib.getCommandRegister().getCommandStructure().searchForUserCommand(event))
            // Check bot permissions in guild
            .flatMap(userCommand -> checkPermissions(event, userCommand)
                // Have perms, create the builder and collect data
                .flatMap(_bool -> {
                    try {
                        return userCommand.setRequestData(genericSlashLib.getUserContextBuilderConstructor().newInstance(event))
                            .collectData();
                    } catch (Exception e) {
                        return Mono.error(e);
                    }
                })
                .ofType(genericSlashLib.getUserContextBuilderClass())
                .map(UserContextBuilder::build)
                .ofType(genericSlashLib.getUserContextClass())
                // Call the command
                .flatMap(userCommand::executeUser));
    }

    /**
     * Receive a MESSAGE interaction, determine the command, check permissions, and execute.
     *
     * @param event the event produced from a user starting an interaction
     * @return empty if command wasn't callable, a present {@link MessageContext} from post command execution otherwise
     */
    @Override
    public Mono<MC> receiveMessageInteractionEvent(MessageInteractionEvent event) {
        // Since User Interactions are only top level we can just get our command by the name
        return Mono.just(genericSlashLib.getCommandRegister().getCommandStructure().searchForMessageCommand(event))
            // Check bot permissions in guild
            .flatMap(messageCommand -> checkPermissions(event, messageCommand)
                // Have perms, create the builder and collect data
                .flatMap(_bool -> {
                    try {
                        return messageCommand.setRequestData(genericSlashLib.getMessageContextBuilderConstructor().newInstance(event))
                            .collectData();
                    } catch (Exception e) {
                        return Mono.error(e);
                    }
                })
                .ofType(genericSlashLib.getMessageContextBuilderClass())
                .map(MessageContextBuilder::build)
                .ofType(genericSlashLib.getMessageContextClass())
                // Call the command
                .flatMap(messageCommand::executeMessage));
    }
}
