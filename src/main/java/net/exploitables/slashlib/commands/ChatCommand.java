package net.exploitables.slashlib.commands;

import discord4j.core.object.command.ApplicationCommand;
import discord4j.core.object.command.ApplicationCommandInteractionOption;
import discord4j.core.object.command.ApplicationCommandOption;
import discord4j.discordjson.json.ApplicationCommandOptionData;
import discord4j.discordjson.json.ApplicationCommandRequest;
import discord4j.discordjson.json.ImmutableApplicationCommandOptionData;
import discord4j.discordjson.json.ImmutableApplicationCommandRequest;
import net.exploitables.slashlib.context.ChatInputInteractionContext;
import net.exploitables.slashlib.context.ChatInputInteractionContextBuilder;
import net.exploitables.slashlib.utility.OptionsList;
import reactor.core.publisher.Mono;
import reactor.util.annotation.Nullable;

import java.util.*;
import java.util.function.Consumer;

public abstract class ChatCommand extends BaseCommand {
    // null when TopCommand: The type of chat input command this is
    private final ApplicationCommandOption.Type chatType;
    // null when no options: Options for the command
    private List<ApplicationCommandOptionData> options;

    // null when not under a group command
    protected GroupCommand parentCommand;
    // null when not GroupCommand: SubCommands and Sub-GroupCommands
    protected final Map<String, ChatCommand> subCommands;

    protected ChatCommand(String name,
                          String description,
                          @Nullable ApplicationCommandOption.Type type) {
        this(name, description, type, null);
    }
    protected ChatCommand(String name,
                          String description,
                          @Nullable ApplicationCommandOption.Type type,
                          @Nullable List<Long> guildIDs) {
        super(name, description, type, ApplicationCommand.Type.CHAT_INPUT, guildIDs);
        this.chatType = type;
        this.options = null;
        this.parentCommand = null;

        if (type == ApplicationCommandOption.Type.SUB_COMMAND_GROUP) {
            this.subCommands = new HashMap<>();
        } else {
            this.subCommands = null;
        }
    }

    public abstract Mono<ChatInputInteractionContext> executeChat(ChatInputInteractionContext context);

    public abstract ChatInputInteractionContextBuilder setRequestData(ChatInputInteractionContextBuilder context);

    /**
     * @return a representative {@link ApplicationCommandOptionData} of this class to be used as option data
     */
    public ApplicationCommandOptionData asOptionData() {
        ImmutableApplicationCommandOptionData.Builder builder = ApplicationCommandOptionData.builder()
                .name(this.getName())
                .description(this.getDescription())
                .type(this.getChatType().getValue());
        List<ApplicationCommandOptionData> options = this.getOptions();
        if (options != null) {
            builder.options(options);
        }
        return builder.build();
    }

    /**
     * @return a representative {@link ApplicationCommandRequest} to compare/create this data with Discord
     */
    @Override
    public ApplicationCommandRequest asRequest() {
        // Get a builder with common values created and add the options for this command if present
        ImmutableApplicationCommandRequest.Builder builder = this.buildBaseRequest();
        if (this.getOptions() != null) {
            builder.addAllOptions(this.getOptions());
        }
        return builder.build();
    }

    /**
     * @param option an {@link ApplicationCommandOptionData} to add to this command
     */
    public void addOption(ApplicationCommandOptionData option) {
        if (this.options == null) this.options = new ArrayList<>();
        this.options.add(option);
    }

    /**
     * @param option an {@link ApplicationCommandOptionData} builder consumer to add to this command
     */
    public void addOption(Consumer<ImmutableApplicationCommandOptionData.Builder> option) {
        ImmutableApplicationCommandOptionData.Builder builder = ApplicationCommandOptionData.builder();
        option.accept(builder);
        this.addOption(builder.build());
    }

    /**
     * Checks if this command has the same options as a list of options in an {@link discord4j.core.object.command.ApplicationCommandInteraction}.
     * @param aciOptions The ApplicationCommandInteraction options to compare this command's options to.
     * @return true if all of this command's options are in the given list of options (i.e., they all have the same
     * option names and types); false otherwise (or if the lists have different lengths => can't be equal).
     */
    public boolean compareWithAciOptions(List<ApplicationCommandInteractionOption> aciOptions) {
        return OptionsList.compareOptionDataAndAciOptions(this.options, aciOptions);
    }

    /**
     * Sets this command's parent command.
     * @param newParent The command's new parent command.
     * @throws IllegalStateException If this command already has a parent command.
     */
    protected void setParent(GroupCommand newParent) {
        if (this.parentCommand != null) throw new IllegalStateException("This command already has a parent.");
        this.parentCommand = newParent;
    }

    @Override
    public boolean isGlobal() {
        if (this.parentCommand != null) {
            return this.parentCommand.isGlobal();
        } else {
            return super.isGlobal();
        }
    }

    @Nullable
    @Override
    public List<Long> getGuildIDs() {
        if (this.parentCommand != null) {
            return this.parentCommand.getGuildIDs();
        } else {
            return super.getGuildIDs();
        }
    }

    /**
     * Returns this command's parent group command, if it is a subcommand. Null if it is a top level command.
     * @return the parent command (if it exists) or null
     */
    @Nullable
    public GroupCommand getParentCommand() {
        return parentCommand;
    }

    /**
     * Get a sub command of this command, only searches one level
     *
     * @param name the name of the sub command to get
     * @return the sub command if present, null if missing
     */
    public ChatCommand getSubCommand(String name) {
        Objects.requireNonNull(subCommands, "SubCommands field is null");
        return subCommands.getOrDefault(name, null);
    }

    public List<ApplicationCommandOptionData> getOptions() { return options; }
    public ApplicationCommandOption.Type getChatType() { return chatType; }
    public Map<String, ChatCommand> getSubCommands() { return subCommands; }
}
