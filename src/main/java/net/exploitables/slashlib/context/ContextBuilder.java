package net.exploitables.slashlib.context;

import discord4j.core.object.entity.Guild;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.User;
import discord4j.core.object.entity.channel.MessageChannel;
import discord4j.core.object.entity.channel.TopLevelGuildChannel;
import reactor.core.publisher.Mono;
import reactor.util.annotation.NonNull;

import java.util.ArrayList;
import java.util.List;

/**
 * Core logic for all extending builder classes.
 *
 * Classes such as:
 * {@link discord4j.core.event.domain.interaction.ChatInputInteractionEvent}
 * {@link discord4j.core.event.domain.interaction.MessageInteractionEvent}
 * {@link discord4j.core.event.domain.interaction.UserInteractionEvent}
 * do not have a superclass which offers logic for getting the base fields in this class.
 * As such the subclasses that implement this class to handle events must provide the
 *  logic to access and set the fields in this class.
 *
 * It is a bit messy, but results in consistent access during the command lifecycle.
 */
public abstract class ContextBuilder {
    protected final List<Mono<Integer>> requiredMonoList;

    Guild guild;
    MessageChannel messageChannel;
    TopLevelGuildChannel topLevelGuildChannel;
    final @NonNull User user;
    Member member;

    /**
     * Create a new context builder, the user must be specified as all
     *  interaction events provide the user through D4J.
     *
     * @param user the user who called the interaction
     */
    ContextBuilder(@NonNull User user) {
        this.requiredMonoList = new ArrayList<>();

        this.guild = null;
        this.messageChannel = null;
        this.topLevelGuildChannel = null;
        this.user = user;
        this.member = null;
    }

    /**
     * @return a new immutable {@link Context} from this builder.
     */
    public abstract Context build();

    /**
     * Collect the data needed for this Context instance.
     * @return this instance
     */
    public Mono<ContextBuilder> collectData() {
        return Mono.zip(requiredMonoList, (array) -> 1)
            .switchIfEmpty(Mono.error(new DataMissingException(this, "Couldn't collect all data!")))
            //.doOnEach(signal -> System.out.println("Error Signal: " + signal.hasError()))
            .thenReturn(this);
    }

    // Provide these methods as abstract as they must be implemented by
    //  subclasses since the methods to get the data isn't common between events
    public abstract ContextBuilder requireGuild();
    public abstract ContextBuilder requireMessageChannel();
    public abstract ContextBuilder requireTopLevelGuildChannel();
    public abstract ContextBuilder requireMember();
}
