package net.exploitables.slashlib.commands;

import discord4j.discordjson.json.ApplicationCommandOptionData;
import discord4j.discordjson.json.ApplicationCommandRequest;
import discord4j.discordjson.json.ImmutableApplicationCommandOptionData;
import discord4j.rest.util.ApplicationCommandOptionType;
import discord4j.rest.util.PermissionSet;
import net.exploitables.slashlib.context.SlashCommandContext;
import net.exploitables.slashlib.context.SlashCommandContextBuilder;
import reactor.core.publisher.Mono;
import reactor.util.annotation.Nullable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

/**
 * A class which represents all types of Slash Commands.
 */
public abstract class BaseCommand {
    // Command Name
    private final String name;
    // Command Description
    private final String description;
    // The type of command this is
    private final ApplicationCommandOptionType type;
    // Options for the command
    private final List<ApplicationCommandOptionData> options;
    // If a user needs permission to execute this command
    private final boolean permissionRequired;
    // Permissions needed by the bot
    private final PermissionSet botPermissions;

    // Sometimes null: SubCommands
    protected final Map<String, BaseCommand> subCommands;

    protected BaseCommand(String name,
                          String description,
                          @Nullable ApplicationCommandOptionType type) {
        this.name = name;
        this.description = description;
        this.type = type;
        this.options = new ArrayList<>();
        this.permissionRequired = false;
        this.botPermissions = PermissionSet.none();

        if (type == ApplicationCommandOptionType.SUB_COMMAND_GROUP) {
            this.subCommands = new HashMap<>();
        } else {
            this.subCommands = null;
        }
    }

    public abstract Mono<SlashCommandContext> execute(SlashCommandContext context);

    public abstract SlashCommandContextBuilder setRequestData(SlashCommandContextBuilder context);

    public ApplicationCommandOptionData asOptionData() {
        var builder = ApplicationCommandOptionData.builder()
            .name(this.getName())
            .description(this.getDescription())
            .type(this.getType().getValue());
        var options = this.getOptions();
        if (options.size() > 0) { // Avoid the need to check an empty list against an absent possible
            builder.options(options);
        }
        return builder.build();
    }

    public ApplicationCommandRequest asRequest() {
        var builder = ApplicationCommandRequest.builder()
            .name(this.name)
            .description(this.description);
        var options = this.getOptions();
        if (options.size() > 0) { // Avoid the need to check an empty list against an absent possible
            builder.addAllOptions(options);
        }
        if (this.isPermissionRequired()) { // Avoid the need to check false against an absent possible
            builder.defaultPermission(true);
        }
        return builder.build();
    }

    public void addOption(ApplicationCommandOptionData option) {
        this.options.add(option);
    }

    public void addOption(Consumer<ImmutableApplicationCommandOptionData.Builder> option) {
        ImmutableApplicationCommandOptionData.Builder builder = ApplicationCommandOptionData.builder();
        option.accept(builder);
        this.options.add(builder.build());
    }

    public BaseCommand getSubCommand(String name) {
        return subCommands.getOrDefault(name, null);
    }

    public String getName() { return name; }
    public String getDescription() { return description; }
    public ApplicationCommandOptionType getType() { return type; }
    public List<ApplicationCommandOptionData> getOptions() { return options; }
    public boolean isPermissionRequired() { return permissionRequired; }
    public PermissionSet getBotPermissions() { return botPermissions; }
    public Map<String, BaseCommand> getSubCommands() { return subCommands; }
}
