package net.exploitables.slashlib;

import discord4j.discordjson.json.ApplicationCommandData;
import discord4j.discordjson.json.ApplicationCommandOptionChoiceData;
import discord4j.discordjson.json.ApplicationCommandOptionData;
import discord4j.discordjson.json.ApplicationCommandRequest;
import discord4j.discordjson.possible.Possible;
import discord4j.rest.service.ApplicationService;
import net.exploitables.slashlib.commands.BaseCommand;

import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

public class CommandRegister {
    //private static final Logger logger = LoggerFactory.getLogger(CommandRegister.class);

    private final CommandStructure commands;

    protected CommandRegister() {
        this.commands = new CommandStructure();
    }

    static CommandRegister create(List<BaseCommand> commandList) {
        CommandRegister commandRegister = new CommandRegister();
        for (BaseCommand command : commandList) {
            commandRegister.addCommand(command);
        }
        return commandRegister;
    }

    private void addCommand(BaseCommand command) {
        this.commands.addSubCommand(command);
    }

    public int registerSlashCommands(ApplicationService applicationService, long applicationId) {
        // Get the commands we have registered
        List<ApplicationCommandData> acds = applicationService.getGlobalApplicationCommands(applicationId).collectList().block();
        Objects.requireNonNull(acds); // TODO: Need to check what happens when no slash commands are registered
        // Get the requests for each command
        List<ApplicationCommandRequest> acrs = new LinkedList<>();
        for (BaseCommand command : commands.getSubCommands().values()) {
            acrs.add(command.asRequest());
        }

        // Check that each Request matches the registered data
        for (int i = 0; i < acrs.size();) {
            ApplicationCommandRequest acr = acrs.get(i);
            ApplicationCommandData acd = acds.stream().filter(a -> a.name().equals(acr.name())).findFirst().orElse(null);
            // Need to create the request, leave it and continue
            if (acd == null) {
                i++;
                continue;
            }
            // Request matches the data, remove the request as it doesn't need to be made
            if (commandDataEqualsRequest(acd, acr)) {
                acrs.remove(i);
                continue;
            }
            // Request doesn't match the data, update it
            applicationService.modifyGlobalApplicationCommand(applicationId, Long.parseLong(acd.id()), acr).block();
            i++;
        }

        // Create each new command
        for (ApplicationCommandRequest acr : acrs) {
            applicationService.createGlobalApplicationCommand(applicationId, acr).block();
        }

        return acrs.size();
    }

    private boolean commandDataEqualsRequest(ApplicationCommandData acd, ApplicationCommandRequest acr) {
        if (!(acr.name().equals(acd.name())
            && acr.description().equals(acd.description())
            && defaultPermissionEquals(acr.defaultPermission(), acd.defaultPermission()) )) {
            return false;
        }

        if (optionsAreEmpty(acd.options(), acr.options())) {
            return true;
        }

        return commandOptionsEqualsList(acd.options().get(), acr.options().get());
    }

    private boolean commandOptionsEqualsList(List<ApplicationCommandOptionData> list1, List<ApplicationCommandOptionData> list2) {
        if (list1.size() != list2.size()) return false;
        for (ApplicationCommandOptionData acod1 : list1) {
            ApplicationCommandOptionData acod2 = list2.stream().filter(a -> a.name().equals(acod1.name())).findFirst().orElse(null);
            if (acod2 != null) {
                // Recursive bit here
                if (!commandOptionsEquals(acod1, acod2)) {
                    return false;
                }
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean commandOptionsEquals(ApplicationCommandOptionData acod1, ApplicationCommandOptionData acod2) {
        if (!(acod1.name().equals(acod2.name())
                && acod1.description().equals(acod2.description())
                && acod1.type() == acod2.type()
                && requiredEquals(acod1.required(), acod2.required())
                && acod1.choices().isAbsent() == acod2.choices().isAbsent())) {  // Quick check
            return false;
        }

        // Either they're both absent or present, only need to check one
        if (!acod1.choices().isAbsent()) {
            if (!commandChoicesEqualsList(acod1.choices().get(), acod2.choices().get())) {
                return false;
            }
        }

        // Ensure the options aren't empty, may be a list of zero length
        if (!optionsAreEmpty(acod1.options(), acod2.options())) {
            // Maintain consistency
            //noinspection RedundantIfStatement
            if (!commandOptionsEqualsList(acod1.options().get(), acod2.options().get())) {
                return false;
            }
        }

        return true;
    }

    private boolean commandChoicesEqualsList(List<ApplicationCommandOptionChoiceData> list1, List<ApplicationCommandOptionChoiceData> list2) {
        if (list1.size() != list2.size()) return false;
        for (ApplicationCommandOptionChoiceData acocd1 : list1) {
            ApplicationCommandOptionChoiceData acocd2 = list2.stream().filter(a -> a.name().equals(acocd1.name())).findFirst().orElse(null);
            if (acocd2 != null) {
                if (!commandChoicesEquals(acocd1, acocd2)) {
                    return false;
                }
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean commandChoicesEquals(ApplicationCommandOptionChoiceData acocd1, ApplicationCommandOptionChoiceData acocd2) {
        // Method of comparing values taken from ApplicationCommandOptionChoice
        return (acocd1.name().equals(acocd2.name()) && String.valueOf(acocd1.value()).equals(String.valueOf(acocd2)));
    }

    private boolean defaultPermissionEquals(Possible<Boolean> p1, Possible<Boolean> p2) {
        // The data may not have the permission value present due to behavior as of D4J v3.2.0-RC2
        // When setting the default permission to true, the request sends a present possible

        // Each half will return true if the value itself is true or if it is not present (two states for true)
        //  it will return false only when the value itself is false
        // In total this statement will return true only if the values equate to the default permission being true,
        //  or both values are false
        return p1.toOptional().orElse(true) == p2.toOptional().orElse(true);
    }

    private boolean requiredEquals(Possible<Boolean> p1, Possible<Boolean> p2) {
        // The data may not have the required value present due to behavior as of D4J v3.2.0-RC2
        // When setting required to false, the request sends a present possible

        // Each half will return true if the value itself is true
        //  it will return false when the value itself is false or it is not present
        // In total this statement will return true only if the values equate to required being false,
        //  or both values are true
        return p1.toOptional().orElse(false) == p2.toOptional().orElse(false);
    }

    private boolean optionsAreEmpty(Possible<List<ApplicationCommandOptionData>> p1, Possible<List<ApplicationCommandOptionData>> p2) {
        // The data may have no value present due to behavior as of D4J v3.2.0-RC2
        // When no options are present, the request sends a present empty list

        // Each half will return true when the list is not present, or has a length of zero
        //  it will return false when the size is not zero
        // In total this statement will return true only if both lists are either absent or have a length of zero
        return p1.toOptional().map(List::size).map(s -> s == 0).orElse(true) && p2.toOptional().map(List::size).map(s -> s == 0).orElse(true);
    }

    public CommandStructure getCommands() { return commands; }
}
