package net.exploitables.slashlib;

import discord4j.common.util.Snowflake;
import discord4j.core.object.command.ApplicationCommandInteraction;
import discord4j.core.object.command.ApplicationCommandInteractionOption;
import net.exploitables.slashlib.commands.generic.GenericChatCommand;
import net.exploitables.slashlib.commands.generic.GenericMessageCommand;
import net.exploitables.slashlib.commands.generic.GenericUserCommand;
import net.exploitables.slashlib.context.*;
import net.exploitables.slashlib.utility.CommandOptionPair;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * A representation of the command structure used for slash commands.
 *
 * Some notes on my (HunHage) observations about slash commands
 * - Each "path" in the command tree must lead to a command.
 * -- This means if /command sub_command is a command then /command is not a callable command.
 * -- Same goes for /command group_command sub_command for command and group_command.
 * - The "name" of any type of command is just the name of that command.
 * -- /command group_command sub_command each have their own names and don't contain each other.
 * -- Discord seems to only navigate down, not up. See the next note section about options.
 * - The Group and Sub commands are options of the above command.
 * -- Knowing about the "path" and "name" means that if a command is not callable then it will
 *     have one option of type GROUP_COMMAND or SUB_COMMAND. We can assume that if there is 0 options,
 *     1 option that is not group/sub, or 2+ options of any type then the command is callable. This is key.
 *
 * With the above observations a tree is the optimal choice for organizing slash commands by name.
 * That is what this class exists to do.
 *
 * Where Discord slash commands exist as:
 * Root
 * - Command
 * - Command
 * -- GenericSubCommand
 * -- GenericSubCommand
 * -- GenericGroupCommand
 * --- GenericSubCommand
 *
 * The Tree will use classes as:
 * CommandStructure
 * - GenericTopCommand
 * - GenericTopGroupCommand
 * -- GenericSubCommand
 * -- GenericSubCommand
 * -- GenericMidGroupCommand
 * --- GenericSubCommand
 *
 * Commands need no knowledge of their parent or involvement in the tree.
 * Since only Commands and SubCommands are callable, GroupCommands are used for each uncallable command.
 *
 * User and Message context menu "commands" are kept in their own hashmap to avoid name collisions but are assembled
 *  as TopCommands when creating request data.
 */
public class CommandStructure<
        CI extends ChatInputContext, CB extends ChatInputContextBuilder,
        MC extends MessageContext, MB extends MessageContextBuilder,
        UC extends UserContext, UB extends UserContextBuilder
        > {
    private final Map<String, GenericChatCommand<CI, CB>> globalChatCommands;
    private final Map<String, GenericUserCommand<UC, UB>> globalUserCommands;
    private final Map<String, GenericMessageCommand<MC, MB>> globalMessageCommands;

    // Admittedly a bit redundant, but used to determine if a command is global
    private final Map<Snowflake, GenericChatCommand<CI, CB>> globalChatCommandsById;
    private final Map<Snowflake, GenericUserCommand<UC, UB>> globalUserCommandsById;
    private final Map<Snowflake, GenericMessageCommand<MC, MB>> globalMessageCommandsById;

    private final Map<String, GenericChatCommand<CI, CB>> guildChatCommands;
    private final Map<String, GenericUserCommand<UC, UB>> guildUserCommands;
    private final Map<String, GenericMessageCommand<MC, MB>> guildMessageCommands;

    /**
     * Create the Command Structure used for Slash Commands
     */
    public CommandStructure() {
        globalChatCommands = new HashMap<>();
        globalUserCommands = new HashMap<>();
        globalMessageCommands = new HashMap<>();

        globalChatCommandsById = new HashMap<>();
        globalUserCommandsById = new HashMap<>();
        globalMessageCommandsById = new HashMap<>();

        guildChatCommands = new HashMap<>();
        guildUserCommands = new HashMap<>();
        guildMessageCommands = new HashMap<>();
    }

    /**
     * Get the Command called with a slash command.
     * Since Discord only allows callable commands to be called, we will have a command to return.
     *
     * @param aci the ApplicationCommandInteraction for a Slash Command
     * @return the Command being called
     */
    public CommandOptionPair<CI, CB> searchForChatCommand(ApplicationCommandInteraction aci) {
        Objects.requireNonNull(aci.getName().orElse(null), "ApplicationCommandInteraction name missing!");
        GenericChatCommand<CI, CB> command = this.globalChatCommands.get(aci.getName().get());
        List<ApplicationCommandInteractionOption> options = aci.getOptions();
        // If there is only one option and it's a GenericSubCommand or SubCommandGroup option then search for it
        if (options.size() == 1 && options.get(0).getType().getValue() < 3) {
            return searchForChatCommand(command, options);
        } else {
            return new CommandOptionPair<>(command, options);
        }
    }

    /**
     * Search for a second or third level command recursively
     * @param command the command to check and search
     * @param options the options for this command
     * @return a callable command
     */
    private CommandOptionPair<CI, CB> searchForChatCommand(GenericChatCommand<CI, CB> command, List<ApplicationCommandInteractionOption> options) {
        // If there is only one option and it's a GenericSubCommand or SubCommandGroup option then search for it
        if (options.size() == 1 && options.get(0).getType().getValue() < 3) {
            ApplicationCommandInteractionOption option = options.get(0);
            return searchForChatCommand(command.getSubCommand(option.getName()), option.getOptions());
        } else {
            return new CommandOptionPair<>(command, options);
        }
    }

    void addGlobalChatCommand(GenericChatCommand<CI, CB> command) {
        globalChatCommands.put(command.getName(), command);
    }

    void addGlobalUserCommand(GenericUserCommand<UC, UB> command) {
        globalUserCommands.put(command.getName(), command);
    }

    void addGlobalMessageCommand(GenericMessageCommand<MC, MB> command) {
        globalMessageCommands.put(command.getName(), command);
    }

    void addGlobalChatCommand(GenericChatCommand<CI, CB> command, Snowflake id) {
        globalChatCommandsById.put(id, command);
    }

    void addGlobalUserCommand(GenericUserCommand<UC, UB> command, Snowflake id) {
        globalUserCommandsById.put(id, command);
    }

    void addGlobalMessageCommand(GenericMessageCommand<MC, MB> command, Snowflake id) {
        globalMessageCommandsById.put(id, command);
    }

    void addGuildChatCommand(GenericChatCommand<CI, CB> command) {
        guildChatCommands.put(command.getName(), command);
    }

    void addGuildUserCommand(GenericUserCommand<UC, UB> command) {
        guildUserCommands.put(command.getName(), command);
    }

    void addGuildMessageCommand(GenericMessageCommand<MC, MB> command) {
        guildMessageCommands.put(command.getName(), command);
    }

    public Map<String, GenericChatCommand<CI, CB>> getGlobalChatCommands() { return this.globalChatCommands; }
    public Map<String, GenericUserCommand<UC, UB>> getGlobalUserCommands() { return this.globalUserCommands; }
    public Map<String, GenericMessageCommand<MC, MB>> getGlobalMessageCommands() { return this.globalMessageCommands; }
}
