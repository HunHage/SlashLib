package net.exploitables.slashlib;

import discord4j.common.util.Snowflake;
import discord4j.core.object.command.ApplicationCommandInteraction;
import discord4j.core.object.command.ApplicationCommandInteractionOption;
import net.exploitables.slashlib.commands.*;
import net.exploitables.slashlib.utility.CommandOptionPair;
import reactor.util.annotation.NonNull;
import reactor.util.annotation.Nullable;

import java.util.*;

/**
 * A representation of the command structure used for slash commands.
 *
 * Some notes on my (HunHage) observations about slash commands
 * - Each "path" in the command tree must lead to a command.
 * -- This means if /command sub_command is a command then /command is not a callable command.
 * -- Same goes for /command group_command sub_command for command and group_command.
 * - The "name" of any type of command is just the name of that command.
 * -- /command group_command sub_command each have their own names and don't contain each other.
 * -- Discord seems to only navigate down, not up. See the next note section about options.
 * - The Group and Sub commands are options of the above command.
 * -- Knowing about the "path" and "name" means that if a command is not callable then it will
 *     have one option of type GROUP_COMMAND or SUB_COMMAND. We can assume that if there is 0 options,
 *     1 option that is not group/sub, or 2+ options of any type then the command is callable. This is key.
 *
 * With the above observations a tree is the optimal choice for organizing slash commands by name.
 * That is what this class exists to do.
 *
 * Where Discord slash commands exist as:
 * Root
 * - Command
 * - Command
 * -- SubCommand
 * -- SubCommand
 * -- GroupCommand
 * --- SubCommand
 *
 * The Tree will use classes as:
 * CommandStructure
 * - TopCommand
 * - TopGroupCommand
 * -- SubCommand
 * -- SubCommand
 * -- MidGroupCommand
 * --- SubCommand
 *
 * Commands need no knowledge of their parent or involvement in the tree.
 * Since only Commands and SubCommands are callable, GroupCommands are used for each uncallable command.
 *
 * User and Message context menu "commands" are kept in their own hashmap to avoid name collisions but are assembled
 *  as TopCommands when creating request data.
 */
public class CommandStructure {
    private final Map<String, ChatCommand> chatCommands;  // map with all global chat commands
    private final Map<String, UserCommand> userCommands;  // map with all global user commands
    private final Map<String, MessageCommand> messageCommands;  // map with all global message commands
    private final Map<Long, Map<String, ChatCommand>> guildChatCommands;  // map with all guild-restricted chat commands
    private final Map<Long, Map<String, UserCommand>> guildUserCommands;  // map with all guild-restricted user commands
    private final Map<Long, Map<String, MessageCommand>> guildMessageCommands;  // map with all guild-restricted msg commands
    private final Set<Long> allCommandGuildIDs;  // set with all guild IDs which there are commands restricted to.

    /**
     * Create the Command Structure used for Slash Commands
     */
    public CommandStructure() {
        chatCommands = new HashMap<>();
        userCommands = new HashMap<>();
        messageCommands = new HashMap<>();
        guildChatCommands = new HashMap<>();
        guildUserCommands = new HashMap<>();
        guildMessageCommands = new HashMap<>();
        allCommandGuildIDs = new HashSet<>();
    }

    /**
     * Generic method used for {@link CommandStructure#searchForUserCommand(ApplicationCommandInteraction, Long)} and
     * {@link CommandStructure#searchForMessageCommand(ApplicationCommandInteraction, Long)}.
     * Used to look for a GUILD-RESTRICTED OR GLOBAL command instance after an interaction event.
     * @param aci The {@link ApplicationCommandInteraction} object obtained in the interaction event.
     * @param globalCmds Map with all global commands of the desired command type.
     * @param guildCmds Map with all guild-restricted commands of the desired command type.
     * @param guildID ID of the guild where the command in the event was run.
     * @param <C> The desired command type.
     * @return The instance of the command (global or guild-restricted) that was run, if found, or empty optional if not found.
     */
    private <C extends BaseCommand> Optional<C> searchForCommandOfType(ApplicationCommandInteraction aci,
                                                                       Map<String, C> globalCmds,
                                                                       Map<Long, Map<String, C>> guildCmds,
                                                                       @Nullable Long guildID) {
        Objects.requireNonNull(aci.getName().orElse(null), "ApplicationCommandInteraction name missing!");
        if (guildID == null) return searchForCommandOfType(aci, globalCmds);
        String cmdName = aci.getName().get();
        C guildCommand = null;
        Map<String, C> cmdsForThisGuild = guildCmds.get(guildID);
        if (cmdsForThisGuild != null) {
            guildCommand = cmdsForThisGuild.get(cmdName);
        }

        C globalCommand = globalCmds.get(cmdName);
        C command = null;  // which command was run, the guild-only one or global one? (in case there are two with the same name)
                           // (According to the Discord API Docs, there can be a global and a guild command with the same name.)

        if (guildCommand == null) {  // if there is no guild-only command with this name
            command = globalCommand;  // only possible option - no guild-only command with the same name
        } else if (globalCommand == null) {  // if there is no global command with this name
            command = guildCommand;  // only possible option - no global command with the same name
        } else {  // if there are two commands - one global and one guild-only - with the same name, then compare IDs
            Optional<Snowflake> maybeAciID = aci.getId();  // get the ID of the command that was run
            if (maybeAciID.isPresent()) {
                String globalCmdID = globalCommand.getCommandGlobalID();
                String aciID = maybeAciID.get().toString();
                if (globalCmdID != null && globalCmdID.equals(aciID)) {
                    command = globalCommand;  // it was the same ID as the global cmd we found, that's it then.
                } else {
                    Optional<String> maybeGuildCmdID = guildCommand.getCommandGuildID(guildID);
                    if (maybeGuildCmdID.isPresent() && maybeGuildCmdID.get().equals(aciID)) {
                        command = guildCommand;   // it was the same ID as the guild cmd we found, that's it then.
                    }
                }
            }
        }

        return Optional.ofNullable(command);
    }

    /**
     * Generic method used for {@link CommandStructure#searchForChatCommand(ApplicationCommandInteraction)},
     * {@link CommandStructure#searchForUserCommand(ApplicationCommandInteraction)} and
     * {@link CommandStructure#searchForMessageCommand(ApplicationCommandInteraction)}.
     * Used to look for a GLOBAL command instance after an interaction event.
     * @param aci The {@link ApplicationCommandInteraction} object obtained in the interaction event.
     * @param globalCmds Map with all global commands of the desired command type.
     * @param <C> The desired command type.
     * @return The instance of the command (global-only) that was run, if found, or empty optional if not found.
     */
    private <C extends BaseCommand> Optional<C> searchForCommandOfType(ApplicationCommandInteraction aci,
                                                                       Map<String, C> globalCmds) {
        Objects.requireNonNull(aci.getName().orElse(null), "ApplicationCommandInteraction name missing!");
        return Optional.ofNullable(globalCmds.get(aci.getName().get()));
    }

    /**
     * Get the Command called with a GUILD-RESTRICTED OR GLOBAL slash command. (Both are checked.)
     * Since Discord only allows callable commands to be called, we will have a command to return.
     *
     * @param aci the ApplicationCommandInteraction for a Slash Command
     * @param guildID the guild ID in which this command was called, to check for guild-specific commands.
     * @return the Command being called
     */
    public CommandOptionPair searchForChatCommand(ApplicationCommandInteraction aci, Long guildID) {
        Objects.requireNonNull(aci.getName().orElse(null), "ApplicationCommandInteraction name missing!");
        if (guildID == null) return searchForChatCommand(aci);
        String cmdName = aci.getName().get();
        List<ApplicationCommandInteractionOption> options = aci.getOptions();
        Optional<ChatCommand> maybeGuildCmd = this.getGuildChatCommand(cmdName, guildID);
        ChatCommand globalCommand = this.chatCommands.get(cmdName);
        ChatCommand command = null;  // which command was run, the guild-only one or global one? (in case there are two with the same name)
                                     // (According to the Discord API Docs, there can be a global and a guild command with the same name.)

        if (!maybeGuildCmd.isPresent()) {  // if there is no guild-only command with this name
            command = globalCommand;  // only possible option - no guild-only command with the same name
        } else if (globalCommand == null) {  // if there is no global command with this name
            command = maybeGuildCmd.get();  // only possible option - no global command with the same name
        } else {  // if there are two commands - one global and one guild-only - with the same name, then compare IDs
            Optional<Snowflake> maybeAciID = aci.getId();   // get the ID of the command that was run
            ChatCommand guildCommand = maybeGuildCmd.get();
            if (maybeAciID.isPresent()) {
                String globalCmdID = globalCommand.getCommandGlobalID();
                String aciID = maybeAciID.get().toString();
                if (globalCmdID != null && globalCmdID.equals(aciID)) {
                    command = globalCommand;  // it was the same ID as the global cmd we found, that's it then.
                } else {
                    Optional<String> maybeGuildCmdID = guildCommand.getCommandGuildID(guildID);
                    if (maybeGuildCmdID.isPresent() && maybeGuildCmdID.get().equals(aciID)) {
                        command = guildCommand;   // it was the same ID as the guild cmd we found, that's it then.
                    }
                }
            }
            if (command == null) {  // we have two commands with same name and still weren't able to make out which one was called
                if (guildCommand.compareWithAciOptions(options)) {  // so let's compare options then (if ID didn't work)
                    command = guildCommand;  // same options as guild cmd so should be fine (check most specific first)
                } else if (globalCommand.compareWithAciOptions(options)) {
                    command = globalCommand;  // same options as global cmd so should be fine
                }
            }  // if it's still null then that's a command that we didn't account for. Probably registered without this lib.
        }

        // If there is only one option and it's a SubCommand or SubCommandGroup option then search for it
        if (options.size() == 1 && options.get(0).getType().getValue() < 3) {
            return searchForChatCommand(command, options);
        } else {
            return new CommandOptionPair(command, options);
        }
    }

    /**
     * Get the Command called with a GLOBAL slash command.
     * Since Discord only allows callable commands to be called, we will have a command to return.
     *
     * @param aci the ApplicationCommandInteraction for a Slash Command
     * @return the Command being called
     */
    public CommandOptionPair searchForChatCommand(ApplicationCommandInteraction aci) {
        ChatCommand command = searchForCommandOfType(aci, this.chatCommands).orElse(null);
        List<ApplicationCommandInteractionOption> options = aci.getOptions();
        // If there is only one option and it's a SubCommand or SubCommandGroup option then search for it
        if (options.size() == 1 && options.get(0).getType().getValue() < 3) {
            return searchForChatCommand(command, options);
        } else {
            return new CommandOptionPair(command, options);
        }
    }

    /**
     * Search for a second or third level command recursively
     * @param command the command to check and search
     * @param options the options for this command
     * @return a callable command
     */
    private CommandOptionPair searchForChatCommand(ChatCommand command, List<ApplicationCommandInteractionOption> options) {
        // If there is only one option and it's a SubCommand or SubCommandGroup option then search for it
        if (options.size() == 1 && options.get(0).getType().getValue() < 3) {
            ApplicationCommandInteractionOption option = options.get(0);
            return searchForChatCommand(command.getSubCommand(option.getName()), option.getOptions());
        } else {
            return new CommandOptionPair(command, options);
        }
    }

    /**
     * Search for a GUILD-RESTRICTED OR GLOBAL user command. (Both are checked.)
     * @param aci The {@link ApplicationCommandInteraction} object obtained in the interaction event.
     * @param guildID The guild ID in which this command was called, to check for guild-specific commands.
     * @return The user command (global or guild-restricted) that was run, if found, or empty optional if not found.
     */
    public Optional<UserCommand> searchForUserCommand(ApplicationCommandInteraction aci, Long guildID) {
        return searchForCommandOfType(aci, this.userCommands, this.guildUserCommands, guildID);
    }

    /**
     * Search for a GLOBAL user command.
     * @param aci The {@link ApplicationCommandInteraction} object obtained in the interaction event.
     * @return The global user command that was run, if found, or empty optional if not found.
     */
    public Optional<UserCommand> searchForUserCommand(ApplicationCommandInteraction aci) {
        return searchForCommandOfType(aci, this.userCommands);
    }

    /**
     * Search for a GUILD-RESTRICTED OR GLOBAL message command. (Both are checked.)
     * @param aci The {@link ApplicationCommandInteraction} object obtained in the interaction event.
     * @param guildID The guild ID in which this command was called, to check for guild-specific commands.
     * @return The message command (global or guild-restricted) that was run, if found, or empty optional if not found.
     */
    public Optional<MessageCommand> searchForMessageCommand(ApplicationCommandInteraction aci, Long guildID) {
        return searchForCommandOfType(aci, this.messageCommands, this.guildMessageCommands, guildID);
    }

    /**
     * Search for a GLOBAL message command.
     * @param aci The {@link ApplicationCommandInteraction} object obtained in the interaction event.
     * @return The global message command that was run, if found, or empty optional if not found.
     */
    public Optional<MessageCommand> searchForMessageCommand(ApplicationCommandInteraction aci) {
        return searchForCommandOfType(aci, this.messageCommands);
    }

    /**
     * Add a command to this group, can be a TopCommand or TopGroupCommand
     *
     * @param command the sub command to add to this group
     */
    public void addChatCommand(ChatCommand command) {
        if (!(command instanceof TopCommand || command instanceof TopGroupCommand)) {
            throw new InvalidCommandLocationException(command, "TopCommand or TopGroupCommand");
        }

        Set<Long> thisCmdGuildIDs = command.getGuildIDs();
        if (!command.isGlobal() && thisCmdGuildIDs != null) {  // guild-restricted cmd
            allCommandGuildIDs.addAll(thisCmdGuildIDs);  // keep track of guild-restricted commands
            for (Long guildID : thisCmdGuildIDs) {
                Map<String, ChatCommand> guildCmds = guildChatCommands.getOrDefault(guildID, new HashMap<>());
                guildCmds.put(command.getName(), command);
                guildChatCommands.put(guildID, guildCmds);
            }
        } else {  // global cmd
            chatCommands.put(command.getName(), command);
        }
    }

    /**
     * Add a user command to this structure.
     *
     * @param command the user context command to add
     */
    public void addUserCommand(UserCommand command) {
        Set<Long> thisCmdGuildIDs = command.getGuildIDs();
        if (!command.isGlobal() && thisCmdGuildIDs != null) {  // guild-restricted cmd
            allCommandGuildIDs.addAll(thisCmdGuildIDs);  // keep track of guild-restricted commands
            for (Long guildID : thisCmdGuildIDs) {
                Map<String, UserCommand> guildCmds = guildUserCommands.getOrDefault(guildID, new HashMap<>());
                guildCmds.put(command.getName(), command);
                guildUserCommands.put(guildID, guildCmds);
            }
        } else {  // global cmd
            userCommands.put(command.getName(), command);
        }
    }

    /**
     * Add a message command to this structure.
     *
     * @param command the message context command to add
     */
    public void addMessageCommand(MessageCommand command) {
        Set<Long> thisCmdGuildIDs = command.getGuildIDs();
        if (!command.isGlobal() && thisCmdGuildIDs != null) {  // guild-restricted cmd
            allCommandGuildIDs.addAll(thisCmdGuildIDs);  // keep track of guild-restricted commands
            for (Long guildID : thisCmdGuildIDs) {
                Map<String, MessageCommand> guildCmds = guildMessageCommands.getOrDefault(guildID, new HashMap<>());
                guildCmds.put(command.getName(), command);
                guildMessageCommands.put(guildID, guildCmds);
            }
        } else {  // global cmd
            messageCommands.put(command.getName(), command);
        }
    }

    /**
     * Retrieves all global chat commands.
     * @see CommandStructure#getGlobalChatCommands()
     */
    public Map<String, ChatCommand> getChatCommands() { return this.chatCommands; }
    /**
     * Retrieves all global user commands.
     * @see CommandStructure#getGlobalUserCommands()
     */
    public Map<String, UserCommand> getUserCommands() { return this.userCommands; }
    /**
     * Retrieves all global message commands.
     * @see CommandStructure#getGlobalMessageCommands()
     */
    public Map<String, MessageCommand> getMessageCommands() { return this.messageCommands; }
    public Set<Long> getAllCommandGuildIDs() {
        return allCommandGuildIDs;
    }

    /**
     * Retrieves all global chat commands.
     * @return Map with global chat commands (k: name; v: command).
     */
    public Map<String, ChatCommand> getGlobalChatCommands() {
        return getChatCommands();
    }

    /**
     * Retrieves all global user commands.
     * @return Map with global user commands (k: name; v: command).
     */
    public Map<String, UserCommand> getGlobalUserCommands() {
        return getUserCommands();
    }

    /**
     * Retrieves all global message commands.
     * @return Map with global message commands (k: name; v: command).
     */
    public Map<String, MessageCommand> getGlobalMessageCommands() {
        return getMessageCommands();
    }

    /**
     * Retrieves all guild-restricted chat commands, in all guilds, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @return Map with ALL guild-restricted chat commands (per guild ID).
     */
    public Map<Long, Map<String, ChatCommand>> getGuildChatCommands() {
        return this.guildChatCommands;
    }

    /**
     * Retrieves all guild-restricted chat commands, in a certain guild.
     * @param guildID Guild to check.
     * @return Map with chat commands restricted to that guild ID.
     */
    public @NonNull Map<String, ChatCommand> getGuildChatCommands(long guildID) {
        return this.guildChatCommands.getOrDefault(guildID, new HashMap<>());
    }

    /**
     * Retrieves all guild-restricted user commands, in all guilds, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @return Map with ALL guild-restricted chat commands (per guild ID).
     */
    public Map<Long, Map<String, UserCommand>> getGuildUserCommands() {
        return this.guildUserCommands;
    }

    /**
     * Retrieves all guild-restricted user commands, in a certain guild.
     * @param guildID Guild to check.
     * @return Map with user commands restricted to that guild.
     */
    public @NonNull Map<String, UserCommand> getGuildUserCommands(long guildID) {
        return this.guildUserCommands.getOrDefault(guildID, new HashMap<>());
    }

    /**
     * Retrieves all guild-restricted message commands, in all guilds, in the form of a map of maps (key: guild ID; value:
     * map with chat commands restricted to this guild ID, in the form of k: command name and v: command instance.)
     * @return Map with ALL guild-restricted message commands (per guild ID).
     */
    public Map<Long, Map<String, MessageCommand>> getGuildMessageCommands() {
        return this.guildMessageCommands;
    }

    /**
     * Retrieves all guild-restricted message commands, in a certain guild.
     * @param guildID Guild to check.
     * @return Map with message commands restricted to that guild.
     */
    public @NonNull Map<String, MessageCommand> getGuildMessageCommands(long guildID) {
        return this.guildMessageCommands.getOrDefault(guildID, new HashMap<>());
    }

    /**
     * Retrieves a guild-restricted chat command with the given name in the given guild ID (or empty Optional if there is
     * no such command).
     * @param cmdName The command name to look for.
     * @param guildID The guild ID to which the command is restricted.
     * @return The chat command, or empty optional if there is no such command.
     */
    public Optional<ChatCommand> getGuildChatCommand(String cmdName, long guildID) {
        Map<String, ChatCommand> guildCmds = getGuildChatCommands(guildID);
        return Optional.ofNullable(guildCmds.get(cmdName));
    }

    /**
     * Retrieves a guild-restricted user command with the given name in the given guild ID (or empty Optional if there is
     * no such command).
     * @param cmdName The command name to look for.
     * @param guildID The guild ID to which the command is restricted.
     * @return The user command, or empty optional if there is no such command.
     */
    public Optional<UserCommand> getGuildUserCommand(String cmdName, long guildID) {
        Map<String, UserCommand> guildCmds = getGuildUserCommands(guildID);
        return Optional.ofNullable(guildCmds.get(cmdName));
    }

    /**
     * Retrieves a guild-restricted message command with the given name in the given guild ID (or empty Optional if there is
     * no such command).
     * @param cmdName The command name to look for.
     * @param guildID The guild ID to which the command is restricted.
     * @return The message command, or empty optional if there is no such command.
     */
    public Optional<MessageCommand> getGuildMessageCommand(String cmdName, long guildID) {
        Map<String, MessageCommand> guildCmds = getGuildMessageCommands(guildID);
        return Optional.ofNullable(guildCmds.get(cmdName));
    }
}
