package net.exploitables.slashlib.commands;

import discord4j.core.object.command.ApplicationCommandOption;
import discord4j.discordjson.json.ApplicationCommandOptionData;
import net.exploitables.slashlib.context.SlashCommandContext;
import net.exploitables.slashlib.context.SlashCommandContextBuilder;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * A Class representing a Group Command at any level. This class should not be directly extended.
 */
public abstract class GroupCommand extends ChatCommand {
    protected GroupCommand(String name, String description) {
        super(name, description, ApplicationCommandOption.Type.SUB_COMMAND_GROUP);
    }

    /**
     * Add a (sub)command to this group
     * Type should be checked before calling this from {@link TopGroupCommand}
     * or {@link MidGroupCommand}
     *
     * @param command the sub command to add to this group
     */
    protected void addSubCommand(ChatCommand command) {
        Objects.requireNonNull(this.subCommands);
        this.subCommands.put(command.getName(), command);
    }

    /**
     * @throws IllegalStateException GroupCommands cannot be called through Discord. Calling this is an error.
     */
    @Override
    @Deprecated
    public Mono<SlashCommandContext> executeChat(SlashCommandContext context) {
        throw new IllegalStateException("GroupCommand execute was invoked.");
    }

    /**
     * @throws IllegalStateException GroupCommands cannot be called through Discord. Calling this is an error.
     */
    @Override
    @Deprecated
    public SlashCommandContextBuilder setRequestData(SlashCommandContextBuilder builder) {
        throw new IllegalStateException("GroupCommand setRequestData was invoked.");
    }

    /**
     * Create a representative {@link ApplicationCommandOptionData} of this class to be used as option data.
     * This also adds the sub commands as options.
     *
     * @return a representative {@link ApplicationCommandOptionData} of this class to be used as option data
     */
    @Override
    public List<ApplicationCommandOptionData> getOptions() {
        Objects.requireNonNull(this.subCommands);
        if (this.subCommands.size() == 0) {
            throw new MissingSubCommandException(this);
        }
        List<ApplicationCommandOptionData> options = new ArrayList<>();
        for (BaseCommand command : this.subCommands.values()) {
            options.add(command.asOptionData());
        }
        return options;
    }
}
