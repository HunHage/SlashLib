package net.exploitables.slashlib;

import discord4j.core.GatewayDiscordClient;
import discord4j.core.event.EventDispatcher;
import discord4j.core.event.domain.Event;
import discord4j.core.event.domain.interaction.ChatInputInteractionEvent;
import discord4j.core.event.domain.interaction.MessageInteractionEvent;
import discord4j.core.event.domain.interaction.UserInteractionEvent;
import net.exploitables.slashlib.context.ChatInputContextBuilder;
import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.Logger;
import reactor.util.Loggers;

import java.util.function.Function;

public class SlashLib {
    private static final Logger logger = Loggers.getLogger(SlashLib.class);

    private static SlashLib singleton = null;

    private CommandRegister commandRegister;
    private EventReceiver receiver;

    private SlashLib() {
        this.commandRegister = null;
        this.receiver = null;
    }

    /**
     * A rough edge, it is presumed that the singleton will be created before this is called.
     * @return the instance of SlashLib
     */
    public static SlashLib get() {
        return singleton;
    }

    /**
     * Create an instance of SlashLib from a builder using defaults if not present. This will do some
     * verification on the commands provided and assert they are the proper classes.
     * @param builder the {@link ChatInputContextBuilder} with custom values
     * @return a new instance of SlashLib which can be used to process commands
     */
    static SlashLib create(SlashLibBuilder builder) {
        if (singleton != null) {
            throw new IllegalStateException("SlashLib already created!");
        }
        SlashLib slashLib = new SlashLib();
        if (builder.receiver == null) {
            slashLib.receiver = new EventReceiverImpl();
        } else {
            slashLib.receiver = builder.receiver;
        }
        slashLib.commandRegister = CommandRegister.create(builder.chatCommands, builder.userCommands, builder.messageCommands);
        singleton = slashLib;
        return singleton;
    }

    /**
     * Register a listener for a Discord event with customized logging.
     *
     * @param eventDispatcher the event dispatcher to register with
     * @param event the event to listen for
     * @param mapper the method to call
     * @param <E> any Discord event
     * @param <T> any Publisher which accepts the event
     */
    private <E extends Event, T> void registerListener(EventDispatcher eventDispatcher, Class<E> event, Function<E, Publisher<T>> mapper) {
        eventDispatcher.on(event)
            .flatMap(e -> Flux.defer(() -> mapper.apply(e))
                .onErrorResume(t -> {
                    logger.error("Error while handling CHAT_INPUT event");
                    logger.error(t.getClass().getCanonicalName() + ": " + t.getMessage());
                    return Mono.empty();
                }))
            .subscribe();
    }

    /**
     * Register this instance with an {@link EventDispatcher} to handle:
     * {@link ChatInputInteractionEvent}s when any exist
     * {@link UserInteractionEvent}s when any exist
     *
     * @param eventDispatcher the {@link EventDispatcher} to be used with the bots future {@link GatewayDiscordClient}
     */
    public void registerAsListener(EventDispatcher eventDispatcher) {
        if (commandRegister.getCommandStructure().getChatCommands().size() > 0) {
            registerListener(eventDispatcher, ChatInputInteractionEvent.class, receiver::receiveChatInputInteractionEvent);
        }
        if (commandRegister.getCommandStructure().getUserCommands().size() > 0) {
            registerListener(eventDispatcher, UserInteractionEvent.class, receiver::receiveUserInteractionEvent);
        }
        if (commandRegister.getCommandStructure().getMessageCommands().size() > 0) {
            registerListener(eventDispatcher, MessageInteractionEvent.class, receiver::receiveMessageInteractionEvent);
        }
    }

    /**
     * @return the {@link CommandRegister} used by this instance
     */
    public CommandRegister getCommandRegister() { return commandRegister; }
}
