package net.exploitables.slashlib;

import discord4j.core.object.command.ApplicationCommand;
import discord4j.discordjson.json.ApplicationCommandData;
import discord4j.discordjson.json.ApplicationCommandRequest;
import discord4j.discordjson.possible.Possible;
import discord4j.rest.service.ApplicationService;
import net.exploitables.slashlib.commands.*;
import reactor.util.Logger;
import reactor.util.Loggers;
import reactor.util.annotation.Nullable;

import java.util.*;

public class CommandRegister {
    private static final Logger logger = Loggers.getLogger(CommandRegister.class);

    private final CommandStructure commandStructure;

    protected CommandRegister() {
        this.commandStructure = new CommandStructure();
    }

    /**
     * Create a new CommandRegister with a list of commands.
     * @param chatCommands a list of commands which must be an instance of {@link TopCommand} or {@link GroupCommand}
     * @param userCommands a list of user context menu commands
     * @return a new CommandRegister instance
     */
    static CommandRegister create(List<ChatCommand> chatCommands,
                                  List<UserCommand> userCommands,
                                  List<MessageCommand> messageCommands) {
        logger.debug("Creating CommandRegister");
        CommandRegister commandRegister = new CommandRegister();
        for (ChatCommand command : chatCommands) {
            logger.debug("Adding Chat Command: " + command.getName());
            commandRegister.commandStructure.addChatCommand(command);
        }
        for (UserCommand command : userCommands) {
            logger.debug("Adding User Command: " + command.getName());
            commandRegister.commandStructure.addUserCommand(command);
        }
        for (MessageCommand command : messageCommands) {
            logger.debug("Adding Message Command: " + command.getName());
            commandRegister.commandStructure.addMessageCommand(command);
        }
        logger.debug("CommandRegister created");
        return commandRegister;
    }

    /**
     * Extra GuildIDs list defaults to null (empty) => the only guild IDs checked for commands are the ones
     * for which you specify guild-only commands.
     *
     * @see CommandRegister#registerCommands(ApplicationService, long, Long[])
     */
    public int registerCommands(ApplicationService applicationService, long applicationId) {
        return registerCommands(applicationService, applicationId, null);
    }
    /**
     * Synchronize all (global or guild-restricted) application commands (chat/user/message) with Discord.
     *
     * We merge all requests into a single list as Discord treats them all the same.
     *
     * @param applicationService the bots {@link ApplicationService}
     * @param applicationId the bots Application ID, must match the service
     * @param guildIDs guild IDs to check (beyond those already specified in your commands, in order to delete old guild-only commands),
     *                 or null to just check the ones in your commands.
     * @return the number of application commands created/modified/deleted
     * @throws IllegalStateException when Discord doesn't return an interaction type and when
     *                               an unknown interaction type is received
     *                               (bot has an interaction type registered this library didn't create)
     */
    public int registerCommands(ApplicationService applicationService, long applicationId, @Nullable Long[] guildIDs) {
        int globalCount = registerGlobalCommands(applicationService, applicationId);
        int guildCount = registerGuildCommands(applicationService, applicationId, guildIDs);
        return globalCount + guildCount;
    }

    /**
     * Synchronize all GLOBAL application commands (chat/user/message) with Discord.
     *
     * We merge all requests into a single list as Discord treats them all the same.
     *
     * @param applicationService the bots {@link ApplicationService}
     * @param applicationId the bots Application ID, must match the service
     * @return the number of application commands created/modified/deleted
     * @throws IllegalStateException when Discord doesn't return an interaction type and when
     *                               an unknown interaction type is received
     *                               (bot has an interaction type registered this library didn't create)
     */
    public int registerGlobalCommands(ApplicationService applicationService, long applicationId) {
        logger.debug("Registering application commands with Discord");

        // Since Chat, User, and Message commands can have name collisions we need to allow for that
        //  possibility by spitting them into multiple containers
        Map<String, ApplicationCommandData> discordChatCommands = new HashMap<>();
        Map<String, ApplicationCommandData> discordUserCommands = new HashMap<>();
        Map<String, ApplicationCommandData> discordMessageCommands = new HashMap<>();

        // Get the application commands and put them into their own maps based on type
        // Also ensure we understand all types
        applicationService
            .getGlobalApplicationCommands(applicationId)
            .doOnNext(acd -> {
                if (!acd.type().isAbsent()) {
                    if (acd.type().get() == ApplicationCommand.Type.CHAT_INPUT.getValue()) {
                        logger.debug("Received 'CHAT_INPUT' application command with name: " + acd.name());
                        discordChatCommands.put(acd.name(), acd);
                    } else if (acd.type().get() == ApplicationCommand.Type.USER.getValue()) {
                        logger.debug("Received '      USER' application command with name: " + acd.name());
                        discordUserCommands.put(acd.name(), acd);
                    } else if (acd.type().get() == ApplicationCommand.Type.MESSAGE.getValue()) {
                        logger.debug("Received '   MESSAGE' application command with name: " + acd.name());
                        discordMessageCommands.put(acd.name(), acd);
                    } else {
                        // This should never reasonably occur but in the event it does we do not want to continue
                        //  with updating the commands as an unknown interaction was registered externally.
                        throw new IllegalStateException("Unknown interaction type (" + acd.type().get() + ") with name: " + acd.name());
                    }
                } else {
                    // Thanks Discord, as a solution, do not call this logic until Discord fixes this.
                    // Unfortunately that must be implemented on the user's side.
                    throw new IllegalStateException("Discord did not return a type for an interaction with name: " + acd.name());
                }
            })
            .blockLast();

        // finally, validate the local application commands with the registered ones
        int totalChanges = 0;
        totalChanges += validateCommands(applicationService, applicationId, discordChatCommands, commandStructure.getGlobalChatCommands());
        totalChanges += validateCommands(applicationService, applicationId, discordUserCommands, commandStructure.getGlobalUserCommands());
        totalChanges += validateCommands(applicationService, applicationId, discordMessageCommands, commandStructure.getGlobalMessageCommands());

        logger.info("Created/Updated/Deleted " + totalChanges + " global application commands");
        return totalChanges;
    }

    /**
     * Extra GuildIDs list defaults to null (empty) => the only guild IDs checked for commands are the ones
     * for which you specify guild-only commands.
     *
     * @see CommandRegister#registerGuildCommands(ApplicationService, long, Long[])
     */
    public int registerGuildCommands(ApplicationService applicationService, long applicationId) {
        return registerGuildCommands(applicationService, applicationId, null);
    }
    /**
     * Synchronize all GUILD-RESTRICTED application commands (chat/user/message) with Discord.
     *
     * We merge all requests into a single list as Discord treats them all the same.
     *
     * @param applicationService the bots {@link ApplicationService}
     * @param applicationId the bots Application ID, must match the service
     * @param guildIDs guild IDs to check (beyond those already specified in your commands, in order to delete old ones),
     *                 or null to just check the ones in your commands.
     * @return the number of application commands created/modified/deleted
     * @throws IllegalStateException when Discord doesn't return an interaction type and when
     *                               an unknown interaction type is received
     *                               (bot has an interaction type registered this library didn't create)
     */
    public int registerGuildCommands(ApplicationService applicationService, long applicationId, @Nullable Long[] guildIDs) {
        logger.debug("Registering guild-restricted application commands with Discord");

        Set<Long> effectiveGuildIDs = new HashSet<>(commandStructure.getCommandGuildIDs());

        if (guildIDs == null) {
            guildIDs = new Long[]{};
        } else {
            effectiveGuildIDs.addAll(Arrays.asList(guildIDs));
        }

        Long[] guildIDarray = effectiveGuildIDs.toArray(new Long[0]);
        Map<Long, Map<String, ChatCommand>> allGuildChatCommands = commandStructure.getGuildChatCommands(guildIDarray);
        Map<Long, Map<String, UserCommand>> allGuildUserCommands = commandStructure.getGuildUserCommands(guildIDarray);
        Map<Long, Map<String, MessageCommand>> allGuildMessageCommands = commandStructure.getGuildMessageCommands(guildIDarray);

        int totalChanges = 0;
        for (long currentGuildID : effectiveGuildIDs) {
            // Since Chat, User, and Message commands can have name collisions we need to allow for that
            //  possibility by spitting them into multiple containers
            Map<String, ApplicationCommandData> discordChatCommands = new HashMap<>();
            Map<String, ApplicationCommandData> discordUserCommands = new HashMap<>();
            Map<String, ApplicationCommandData> discordMessageCommands = new HashMap<>();

            // Get the application commands and put them into their own maps based on type
            // Also ensure we understand all types
            applicationService
                    .getGuildApplicationCommands(applicationId, currentGuildID)
                    .doOnNext(acd -> {
                        if (!acd.type().isAbsent()) {
                            if (acd.type().get() == ApplicationCommand.Type.CHAT_INPUT.getValue()) {
                                logger.debug("Received 'CHAT_INPUT' application command restricted to guild " + currentGuildID + " with name: " + acd.name());
                                discordChatCommands.put(acd.name(), acd);
                            } else if (acd.type().get() == ApplicationCommand.Type.USER.getValue()) {
                                logger.debug("Received '      USER' application command restricted to guild " + currentGuildID + " with name: " + acd.name());
                                discordUserCommands.put(acd.name(), acd);
                            } else if (acd.type().get() == ApplicationCommand.Type.MESSAGE.getValue()) {
                                logger.debug("Received '   MESSAGE' application command restricted to guild " + currentGuildID + " with name: " + acd.name());
                                discordMessageCommands.put(acd.name(), acd);
                            } else {
                                // This should never reasonably occur but in the event it does we do not want to continue
                                //  with updating the commands as an unknown interaction was registered externally.
                                throw new IllegalStateException("Unknown interaction type (" + acd.type().get() + ") with name: " + acd.name());
                            }
                        } else {
                            // Thanks Discord, as a solution, do not call this logic until Discord fixes this.
                            // Unfortunately that must be implemented on the user's side.
                            throw new IllegalStateException("Discord did not return a type for an interaction with name: " + acd.name());
                        }
                    })
                    .blockLast();

            // finally, validate the local application commands with the registered ones
            int totalGuildChanges = 0;
            totalGuildChanges += validateCommands(applicationService, applicationId, discordChatCommands, allGuildChatCommands.get(currentGuildID), currentGuildID);
            totalGuildChanges += validateCommands(applicationService, applicationId, discordUserCommands, allGuildUserCommands.get(currentGuildID), currentGuildID);
            totalGuildChanges += validateCommands(applicationService, applicationId, discordMessageCommands, allGuildMessageCommands.get(currentGuildID), currentGuildID);

            logger.info("Created/Updated/Deleted " + totalChanges + " application commands restricted to guild " + currentGuildID);
            totalChanges += totalGuildChanges;
        }
        return totalChanges;
    }

    /**
     * Guild ID set to null (i.e., validating global commands only).
     *
     * @see CommandRegister#validateCommands(ApplicationService, long, Map, Map, Long)
     */
    private <B extends BaseCommand> int validateCommands(ApplicationService applicationService,
                                                         long applicationId,
                                                         Map<String, ApplicationCommandData> registeredCommands,
                                                         Map<String, B> localCommands) {
        return validateCommands(applicationService, applicationId, registeredCommands, localCommands, null);
    }
    /**
     * Validate two lists of commands, this is generified logic that is shared between Chat/User/Message commands
     * The provided maps should be of the same TYPE of command. This is not checked.
     *
     * @param applicationService the bots application service, used to create/modify/delete commands
     * @param applicationId the bots application id for the application service
     * @param registeredCommands the commands registered with discord
     * @param localCommands the commands created locally
     * @param guildID Guild to restrict command changes to (null for global commands)
     * @return the number of commands changed
     */
    private <B extends BaseCommand> int validateCommands(ApplicationService applicationService,
                                                         long applicationId,
                                                         Map<String, ApplicationCommandData> registeredCommands,
                                                         Map<String, B> localCommands,
                                                         @Nullable Long guildID) {
        int changes = 0;
        if (localCommands == null) localCommands = new HashMap<>();
        // Create/Update commands
        for (BaseCommand localCommand : localCommands.values()) {
            ApplicationCommandRequest request = localCommand.asRequest();
            // Command doesn't exist discord side, create it
            if (registeredCommands.get(request.name()) == null) {
                logger.info("Creating " + request.type().get() + " Command: " + request.name() + (guildID != null ? " (in guild ID: " + guildID + ")" : ""));
                if (guildID != null) {
                    applicationService.createGuildApplicationCommand(applicationId, guildID, request).block();
                } else {
                    applicationService.createGlobalApplicationCommand(applicationId, request).block();
                }
                changes++;
                continue;
            }
            // Command exists discord side, check if it's equal to the bot command
            ApplicationCommandData discordCmd = registeredCommands.get(request.name());
            if (!commandDataEqualsRequest(discordCmd, request)) {
                logger.info("Updating " + request.type().get() + " Command: " + discordCmd.name() + (guildID != null ? " (in guild ID: " + guildID + ")" : ""));
                if (guildID != null) {
                    applicationService.modifyGuildApplicationCommand(applicationId, guildID, Long.parseLong(discordCmd.id()), request).block();
                } else {
                    applicationService.modifyGlobalApplicationCommand(applicationId, Long.parseLong(discordCmd.id()), request).block();
                }
                changes++;
            }
        }

        // Delete removed commands
        for (ApplicationCommandData discordCmd : registeredCommands.values()) {
            if (!localCommands.containsKey(discordCmd.name())) {
                logger.info("Deleting " + discordCmd.type().get() + " Command: " + discordCmd.name() + (guildID != null ? " (in guild ID: " + guildID + ")" : ""));
                if (guildID != null) {
                    applicationService.deleteGuildApplicationCommand(applicationId, guildID, Long.parseLong(discordCmd.id())).block();
                } else {
                    applicationService.deleteGlobalApplicationCommand(applicationId, Long.parseLong(discordCmd.id())).block();
                }
                changes++;
            }
        }

        return changes;
    }

    /**
     * Check if a slash commands data returned by Discord matches the local slash command request.
     * The names of each parameter should be the same.
     *
     * @param acd the {@link ApplicationCommandData} returned by Discord for a slash command
     * @param acr the {@link ApplicationCommandRequest} created for the same slash command locally
     * @return true if the local slash command is equal to the one registered on Discord
     */
    private boolean commandDataEqualsRequest(ApplicationCommandData acd, ApplicationCommandRequest acr) {
        if (!(acr.name().equals(acd.name())
            && acr.description().toOptional().map(desc -> desc.equals(acd.description())).orElse(false)
            && defaultPermissionEquals(acr.defaultPermission(), acd.defaultPermission()) )) {
            return false;
        }

        if (!acd.options().isAbsent() && !acr.options().isAbsent()) { // Both have options
            return acd.options().get().equals(acr.options().get());
        } else { // If both don't have options return true, otherwise false
            return acd.options().isAbsent() && acr.options().isAbsent();
        }
    }

    /**
     * The default permission must be set in the {@link ApplicationCommandRequest} but doesn't have to be present
     * in a {@link ApplicationCommandData}. This checks for equivalency between the two.
     *
     * @param p1 a Possible representing the default permission value
     * @param p2 a Possible representing the default permission value
     * @return true if the two possibles are equivalent in the context of being set for the default permission
     */
    private boolean defaultPermissionEquals(Possible<Boolean> p1, Possible<Boolean> p2) {
        // The data may not have the permission value present due to behavior as of D4J v3.2.0-RC2
        // By default, D4J will set the requests' default permission to true

        // Each half will return true if the value itself is true or if it is not present (two states for true)
        //  it will return false only when the value itself is false
        // In total this statement will return true only if the values equate to the default permission being true,
        //  or both values are false
        return p1.toOptional().orElse(true) == p2.toOptional().orElse(true);
    }

    public CommandStructure getCommandStructure() { return commandStructure; }
}
